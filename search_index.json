[
["index.html", "Jasonelle Documentation 1 Welcome 1.1 Main Goals 1.2 Cool things about Jasonelle 1.3 Old Docs 1.4 Examples 1.5 Why JSON?", " Jasonelle Documentation Jasonelle Team 2019-06-09 1 Welcome Jasonelle is an app framework that takes a JSON markup and turns it into Android/iOS native components and function calls, which then can be packaged and distributed as your own app. And the most important part: it‚Äôs 100% open source under MPL-2.0 license, which means you can take it and build your app, submit it to the App Store, and do whatever you want with it!. 1.1 Main Goals Jasonelle project want to reach these goals: Use known and popular technologies (JSON, Javascript). üíØ Easy to learn, use and extend. ‚ò∫Ô∏è Stable API. ‚öì Use Native Components. üì± Great Documentation. üìù Friendly and Welcoming Community. ü§ù 1.2 Cool things about Jasonelle 100% NATIVE: Jasonelle maps JSON into native components and native function calls. There is no gimmick. There is no magic. App loads over HTTP (or local file): Your app exists 100% as JSON, and loads from the cloud or local. No more hard-coding. Send Native App over HTTP Anything that can be expressed in JSON can be sent over the Internet. Anything that can be sent over the Internet doesn‚Äôt need to be on the client. Since Jasonette lets you express the app 100% in JSON, you don‚Äôt need to hard-code your app on the phone anymore. Instead, the app loads directly from the server everytime a user opens the app. An app in 30 minutes: No kidding, build an app in 30 minutes. Describe instead of programming. Instead of writing and compiling complex program lines, you only need to write a single markup that describes what the view should look like and how it should behave. An app that used to take days to build can be built in 30 minutes (or less). Lowest possible learning curve: No programming experience required. There‚Äôs a small amount of things you need to know: JSON (And maybe a little JavaScript). Which means you can build an app without ‚Äúbecoming a programmer‚Äù. Minimum learning curve You can describe the view layout (like HTML), component style (like CSS), and native function calls (like Javascript) ALL in JSON. All you need is a single JSON. 1.3 Old Docs The previous version of this documentation is present in the following url https://jasonelle.com/jasonette-old-docs/. The vast mayority of the old docs are still valid and useful. 1.4 Examples Plenty of code examples are stored in the https://github.com/jasonelle/docs/tree/develop/examples/jasonette repository. 1.5 Why JSON? Industry Standard, lightweight data-interchange format. Huge amount of programming languages and tools with support available. It is easy for humans to read and write. It is easy for machines to parse and generate. A single plain text file can contain all the data and logic needed in a complete native app. You can use any backend to generate the app (or do not use a backend at all). Example: Masonite, ProcessWire, Express, SailsJS, Laravel, Rails, Flask, Django, AWS Lambda, file:// local file. "],
["history.html", "2 History", " 2 History Jasonette was created by ‚ÄúEthan Gliechtenstein‚Äù, a New York developer. Probably from Bushwick. Who‚Äôs real identity nobody knows. Jasonette core began in Late 2014 as an app named ‚ÄúEthan‚Äù (http://www.textethan.com/) It got quickly popular. Ethan App Homepage Tech Crunch https://techcrunch.com/2014/10/30/meet-samantha-ethan-apps-sister/ Ny Times https://www.nytimes.com/2014/12/18/style/ethan-siri-meets-dr-phil.html The Guardian https://www.theguardian.com/technology/2014/dec/04/-sp-ten-best-messaging-apps CNN http://www.cnn.com/2014/10/11/tech/askethan-app Spiegel http://www.spiegel.de/netzwelt/apps/ask-ethan-app-beantwortet-fragen-der-nutzer-a-997335.html Dazed Digital http://www.dazeddigital.com/artsandculture/article/22152/1/this-irl-siri-app-wants-to-answer-all-your-burning-questions Business Insider http://www.businessinsider.com/ethan-is-the-top-app-on-product-hunt-2014-10 SFGate http://www.sfgate.com/business/article/Stupid-apps-but-not-always-a-stupid-idea-5843629.php Ethan App Screenshot If you want to see the prototype Jasonette JSON syntax, see the archived repo here: https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/archived-ethan-app Some time after that Ethan began extracting the core, refining the api and creating documentation. Finally releasing the first version of Jasonette on November 3th 2016. https://www.producthunt.com/posts/jasonette https://twitter.com/jasonclient/status/794175517763272708 Jasonette First Tweet Ethan worked on Jasonette, Cell and ST for nearly 2 years straight full-time. Until June 9 2018 were he misteriosly disappeared without a trace. Later on November 6th 2018. Jasonelle Team took the lead (https://github.com/Jasonette/Jasonette/issues/23). Last known Ethan contribution The original repositories of Jasonette, Cell and ST are: https://github.com/jasonette https://github.com/intercellular https://github.com/selecttransform PD: If you want to know that character Ethan uses it‚Äôs Kon from Bleach üíØ (http://bleach.wikia.com/wiki/Kon) "],
["cell-js.html", "3 Cell.js", " 3 Cell.js Cell.js was a framework to simplify web development using JSON like structures. In the following blog post https://jasonelle.com/blog/cell-js-is-deprecated/, Jasonelle Team anounced that the Cell.js project was now deprecated and no longer maintained. However, you can access plenty of code examples here https://github.com/jasonelle/docs/tree/develop/examples/celljs. Jasonelle Team recommends the following frameworks as replacements: https://svelte.dev/ https://mithril.js.org/ "],
["jasonette.html", "4 Jasonette 4.1 Introduction", " 4 Jasonette Quite a different way to make an app. Make iOS and Android apps with just a single JSON, loaded over HTTP, local file, or anywhere. It has never been trivial to have an idea and turn it into an app quickly. Even for genius programmers. With Jasonette, you don‚Äôt even have to be a programmer. Anyone can make an app. And do it in minutes, not days or weeks. Make an app as fast as it takes to write a blog post. 4.1 Introduction Jasonette abstracts away all low level programming with a JSON based markup. All you need to write is a single JSON. 4.1.1 JSON to Native Components Just like how web browsers turn HTML into a web page, Jasonette turns JSON into iOS and Android native components. This lets you build native apps by writing a simple JSON. Native App over JSON 4.1.1.1 Structure Organize your code in nested JSON objects. Example: { &quot;$jason&quot;: { &quot;head&quot;: {...}, &quot;body&quot;: { &quot;sections&quot;: [{ &quot;items&quot;: [ { &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;...&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;...&quot; }, ... ] }] } } } 4.1.1.2 Layout Construct complex layouts with JSON. Example: Build a card UI with an image, labels, and nested layouts. { &quot;type&quot;: &quot;horizontal&quot;, &quot;components&quot;: [ { &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;file://ethan.jpeg&quot; }, { &quot;type&quot;: &quot;vertical&quot;, &quot;components&quot;: [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Ethan&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot; &quot;www.textethan.com&quot; } ] } ] } 4.1.1.3 Actions Describe actions with JSON. Example: Make a network request and draw the result. { &quot;type&quot;: &quot;$network.request&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;http://api.giphy.com/v1/gifs/search&quot;, &quot;data&quot;: { &quot;q&quot;: &quot;kitten&quot;, &quot;api_key&quot;: &quot;dc6zaTOxFJmzC&quot; } }, &quot;success&quot;: { &quot;type&quot;: &quot;$render&quot; } } 4.1.1.4 Style Style components with JSON. Example: Style a label. { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Hello World&quot;, &quot;style&quot;: { &quot;padding&quot;: &quot;10&quot;, &quot;corner_radius&quot;: &quot;5&quot;, &quot;background&quot;: &quot;rgba(0,0,0,0.4)&quot;, &quot;color&quot;: &quot;#ffffff&quot;, &quot;font&quot;: &quot;HelveticaNeue&quot; } } 4.1.1.5 Native App Over JSON Directly manipulate native APIs simply using JSON. For Android, this means direct access to LinearLayout, RecyclerView, etc. For iOS, this means direct access to UITableView, UIStackView, etc. Want to make changes to your LIVE app? Simply change your JSON content on the server, and watch the app change in front of your eyes, instantly!. 4.1.1.6 Native Components These are some Native Components you can access using just JSON. And much more! Including: Direct access to the device such as camera, audio, geolocation, video, network request, etc. Powerful layout engine that directly manipulates native components such as UITableView, UIStackView, UIView, etc. Describe styling and event handling all with JSON 4.1.1.7 Cross Platform 100% native binary for both Android and iOS. iOS Android 4.1.2 Free &amp; Battle Tested Jasonette was extracted from several production apps on the App Store, so you know it works. Below are some actual production apps built with Jasonette. Kitty Catch All 4.1.2.1 100% FREE Everything is free for you to use. There is no small print that says ‚Äúpay $$$ if you want to publish your app‚Äù. It‚Äôs all yours. 4.1.2.2 100% OPEN SOURCE Jasonette is licensed under MIT license. Take the code, build and publish your own apps, and do whatever you want with it! 4.1.2.3 100% PORTABLE There is no magical backend server you need to learn to use, pay for, or install to use Jasonette. ALL YOU NEED IS JSON. If you have a web server, you ALREADY have a Jasonette server. 4.1.2.4 100% EXTENSIBLE Jasonette is essentially just an engine that maps JSON expression to native components and actions. It doesn‚Äôt force you to drop everything and adopt the technology exclusively. You can extend it or even integrate it with your existing native code seamlessly. "],
["ja-js-selector-transformer.html", "5 Ja.js - Selector Transformer 5.1 Repository 5.2 Playground 5.3 Introduction 5.4 Select 5.5 Transform 5.6 Examples", " 5 Ja.js - Selector Transformer Ja.js (previously named st.js) is a library that enables implementing practically any programming concept in a declarative manner, using JSON. This is because ja.js is a low level building block for creating a Turing Complete JSON markup language. ja.js is the core JSON parser that powers Jasonette, so you can build native iOS/Android apps by writing nothing but a JSON markup. Ja.js But Jasonette is just one implementation. Want to build your own turing complete JSON markup language? 5.1 Repository https://github.com/jasonelle/ja.js 5.2 Playground Parse JSON anywhere, both frontend and backend, as easy as using JSON.stringify or JSON.parse. https://jasonelle.com/docs/playground-ja/ Source Code: https://github.com/jasonelle/docs/tree/develop/playground-ja. 5.3 Introduction ja.js is a library that adds a couple of powerful methods to JavaScript‚Äôs native JSON. So you can simply use it with the syntax ST.select(...).transform(...). The library is just a single file, made up of stateless functions, with NO dependency. Which makes it effortless to embed anywhere without hassle. (Currently used in various environments including iOS, Android, node.js, browser, etc.). What Can I Use It For? JSON powers almost everything in the world. Being able to bend any JSON to your will means you can do all kinds of magical things. Ja.js consist mainly of two operations: Select: Query any JSON tree to select exactly the subtree you are looking for. Transform: Transform any JSON object to another by parsing with a template, also written in JSON You can also mix and match Select AND Transform to perform partial transform, modularize JSON objects, etc. 5.3.1 Select Select a JSON object or its subtree that matches your filter function criteria. Step 1. Take any JSON object var data = { &quot;links&quot;: [ { &quot;remote_url&quot;: &quot;http://localhost&quot; }, { &quot;file_url&quot;: &quot;file://documents&quot; }, { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; } ], &quot;preview&quot;: &quot;https://image&quot;, &quot;metadata&quot;: &quot;This is a link collection&quot; } Step 2. Find all key/value pairs that match a selector function var sel = ST.select(data, function(key, val) { return /https?:/.test(val); }) Step 3. Get the result var keys = sel.keys(); // [ // &quot;remote_url&quot;, // &quot;remote_url&quot;, // &quot;preview&quot; // ] var values = sel.values(); // [ // &quot;http://localhost&quot;, // &quot;https://blahblah.com&quot;, // &quot;https://image&quot; // ] var paths = sel.paths(); // [ // &quot;[\\&quot;links\\&quot;]&quot;, // &quot;[\\&quot;links\\&quot;]&quot;, // &quot;&quot; // ] 5.3.2 Transform Transform any JSON with a declarative template, also in JSON. Step 1. Take any JSON object var data = { &quot;title&quot;: &quot;List of websites&quot;, &quot;description&quot;: &quot;This is a list of popular websites&quot; &quot;data&quot;: { &quot;sites&quot;: [{ &quot;name&quot;: &quot;Google&quot;, &quot;url&quot;: &quot;https://google.com&quot; }, { &quot;name&quot;: &quot;Facebook&quot;, &quot;url&quot;: &quot;https://facebook.com&quot; }, { &quot;name&quot;: &quot;Twitter&quot;, &quot;url&quot;: &quot;https://twitter.com&quot; }, { &quot;name&quot;: &quot;Github&quot;, &quot;url&quot;: &quot;https://github.com&quot; }] } } Step 2. Select and transform with a template JSON object var sel = ST.select(data, function(key, val){ return key === &#39;sites&#39;; }) .transformWith({ &quot;items&quot;: { &quot;{{#each sites}}&quot;: { &quot;tag&quot;: &quot;&lt;a href=&#39;{{url}}&#39;&gt;{{name}}&lt;/a&gt;&quot; } } }) Step 3. Get the result var keys = sel.keys(); // [ // &quot;tag&quot;, // &quot;tag&quot;, // &quot;tag&quot;, // &quot;tag&quot; // ] var values = sel.values(); // [ // &quot;&lt;a href=&#39;https://google.com&#39;&gt;Google&lt;/a&gt;&quot;, // &quot;&lt;a href=&#39;https://facebook.com&#39;&gt;Facebook&lt;/a&gt;&quot;, // &quot;&lt;a href=&#39;https://twitter.com&#39;&gt;Twitter&lt;/a&gt;&quot;, // &quot;&lt;a href=&#39;https://github.com&#39;&gt;Github&lt;/a&gt;&quot; // ] var objects = sel.objects(); // [ // { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://google.com&#39;&gt;Google&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://facebook.com&#39;&gt;Facebook&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://twitter.com&#39;&gt;Twitter&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://github.com&#39;&gt;Github&lt;/a&gt;&quot; // } // ] var root = sel.root(); // { // &quot;items&quot;: [{ // &quot;tag&quot;: &quot;&lt;a href=&#39;https://google.com&#39;&gt;Google&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://facebook.com&#39;&gt;Facebook&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://twitter.com&#39;&gt;Twitter&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://github.com&#39;&gt;Github&lt;/a&gt;&quot; // }] // } 5.3.3 Usage 5.3.3.1 In a browser &lt;script src=&quot;ja.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var parsed = ST.select({ &quot;items&quot;: [1,2,3,4] }) .transformWith({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{this}}&quot; } }) .root(); &lt;/script&gt; 5.3.3.2 In node.js Install through npm: $ npm install stjs Use const ST = require(&#39;st&#39;); const parsed = ST.select({ &quot;items&quot;: [1,2,3,4] }) .transformWith({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{this}}&quot; } }) .root(); 5.4 Select Select a JSON object or its subtree that matches your filter function. 5.4.1 Syntax ST.select(data, selectorFunction); 5.4.1.1 Parameters data : Any JavaScript object selectorFunction : selectorFunction is a predicate, to test each key/value pairs of the entire JSON tree. Return true to keep the element, false otherwise, taking two arguments: key : the ‚Äúkey‚Äù of the current key/value pair being tested. value : the ‚Äúvalue‚Äù of the current key/value pair being tested. 5.4.1.2 Return Value Returns a selection object which can be queried to retrieve the final result, using the following API: values() : Array of values for all the key/value pair matches. keys() : Array of keys for all the key/value pair matches. paths() : Array of paths leading to all the key/value pair matches. objects() : Array of full objects in which the key/value match was found. root() : Retrieve the root node. Useful when used along with transform. 5.4.2 Example You can select any JSON tree to find only the subtrees that satisfy your needs. Take any data var data = { links: [ { &quot;remote_url&quot;: &quot;http://localhost&quot; }, { &quot;file_url&quot;: &quot;file://documents&quot; }, { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; } ], preview: &quot;https://image&quot;, metadata: &quot;This is a link collection&quot; }; Select subtree var selection = ST.select(data, function(key, val) { return /https?:/.test(val); }) Query the selection object var selected_values = selection.values(); // [ // &quot;http://localhost&quot;, // &quot;https://blahblah.com&quot;, // &quot;https://image&quot; // ] var selected_keys = selection.keys(); // [ // &quot;remote_url&quot;, // &quot;remote_url&quot;, // &quot;preview&quot; // ] var selected_objects = selection.objects(); // [ // { &quot;remote_url&quot;: &quot;http://localhost&quot; }, // { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; }, // { // &quot;links&quot;: [ // { &quot;remote_url&quot;: &quot;http://localhost&quot; }, // { &quot;file_url&quot;: &quot;file://documents&quot; }, // { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; } // ], // &quot;preview&quot;: &quot;https://image&quot;, // &quot;metadata&quot;: &quot;This is a link collection&quot; // } // ] // // var selected_paths = selection.paths(); // [ // &quot;[\\&quot;links\\&quot;][0]&quot;, // &quot;[\\&quot;links\\&quot;][2]&quot;, // &quot;&quot; // ] 5.5 Transform Transform any JSON with a declarative template, also in JSON. 5.5.1 Syntax There are 2 ways of transforming an object: 5.5.1.1 transform() Select a template or its subtree, and transform data with the selected template. ST.select(TEMPLATE).transform(DATA) ST.select({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } }) .transform({ items: [ { id: 1, name: &quot;Ja&quot; }, { id: 2, name: &quot;Ka&quot; }, { id: 3, name: &quot;La&quot; } ] }) .root(); 5.5.1.2 transformWith() Select a data object or its subtree and transform with a template. ST.select(DATA).transformWith(TEMPLATE) ST.select({ items: [ { id: 1, name: &quot;Ja&quot; }, { id: 2, name: &quot;Ka&quot; }, { id: 3, name: &quot;La&quot; } ] }) .transformWith({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } }) .root(); 5.5.2 Basic Use {{ }} notation to fill out a template with data to generate a new JSON. Template and Data var template = { &quot;menu&quot;: { &quot;flavor&quot;: &quot;{{flavor}}&quot;, &quot;richness&quot;: &quot;{{richness}}&quot;, &quot;garlic amount&quot;: &quot;{{garlic_amount}}&quot;, &quot;green onion?&quot;: &quot;{{green_onion}}&quot;, &quot;sliced pork?&quot;: &quot;{{pork_amount}}&quot;, &quot;secret sauce&quot;: &quot;{{sauce_amount}}&quot;, &quot;noodle&#39;s texture&quot;: &quot;{{texture}}&quot; } } var data = { &quot;flavor&quot;: &quot;strong&quot;, &quot;richness&quot;: &quot;ultra rich&quot;, &quot;garlic_amount&quot;: &quot;1 clove&quot;, &quot;green_onion&quot;: &quot;thin green onion&quot;, &quot;pork_amount&quot;: &quot;with&quot;, &quot;sauce_amount&quot;: &quot;double&quot;, &quot;texture&quot;: &quot;extra firm&quot; } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;menu&quot;: { &quot;flavor&quot;: &quot;strong&quot;, &quot;richness&quot;: &quot;ultra rich&quot;, &quot;garlic amount&quot;: &quot;1 clove&quot;, &quot;green onion?&quot;: &quot;thin green onion&quot;, &quot;sliced pork?&quot;: &quot;with&quot;, &quot;secret sauce&quot;: &quot;double&quot;, &quot;noodle&#39;s texture&quot;: &quot;extra firm&quot; } } 5.5.3 Loop Use #each to iterate through items. Template and Data var template = { &quot;orders&quot;: { &quot;{{#each customers}}&quot;: { &quot;order&quot;: &quot;One {{menu}} for {{name}}!&quot; } } } var data = { &quot;customers&quot;: [{ &quot;name&quot;: &quot;Hatter&quot;, &quot;menu&quot;: &quot;miso ramen&quot; }, { &quot;name&quot;: &quot;March Hare&quot;, &quot;menu&quot;: &quot;tonkotsu ramen&quot; }, { &quot;name&quot;: &quot;Dormouse&quot;, &quot;menu&quot;: &quot;miso ramen&quot; }, { &quot;name&quot;: &quot;Alice&quot;, &quot;menu&quot;: &quot;cup noodles&quot; }] } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;orders&quot;: [{ &quot;order&quot;: &quot;One miso ramen for Hatter!&quot; }, { &quot;order&quot;: &quot;One tonkotsu ramen for March Hare!&quot; }, { &quot;order&quot;: &quot;One miso ramen for Dormouse!&quot; }, { &quot;order&quot;: &quot;One cup noodles for Alice!&quot; }] } 5.5.4 Conditionals Use #if / #elseif / #else to selectively fill out a template. Template and Data var template = { &quot;response&quot;: [{ &quot;{{#if spicy &lt; 7}}&quot;: { &quot;message&quot;: &quot;Coming right up!&quot; } }, { &quot;{{#elseif spicy &lt; 9}}&quot;: { &quot;message&quot;: &quot;Are you sure? It is very spicy&quot; } }, { &quot;{{#else}}&quot;: { &quot;message&quot;: &quot;Please sign here where it says you&#39;re responsible for this decision&quot; } }] } var data = { &quot;spicy&quot;: 8 } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;response&quot;: { &quot;message&quot;: &quot;Are you sure? It is very spicy&quot; } } 5.5.5 Existencial Operator You can use the existential operator #? to exclude an attribute altogether if the template evaluates to a falsy value. Template and Data var data = { notifications: { home: 1, invite: 2 } }; var template = { tabs: [{ text: &quot;home&quot;, badge: &quot;{{#? notifications.home}}&quot; }, { text: &quot;message&quot;, badge: &quot;{{#? notification.message}}&quot; }, { text: &quot;invite&quot;, badge: &quot;{{#? notification.invite}}&quot; }] } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { tabs: [{ text: &quot;home&quot;, badge: 1 }, { text: &quot;message&quot; }, { text: &quot;invite&quot;, badge: 2 }] } 5.5.6 Concat You can concatenate multiple items and arrays into a single array using the #concat operator. Template and Data var data = { numbers: [1,2,3] }; var template = { &quot;items&quot;: { &quot;{{#concat}}&quot;: [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: {{numbers.length}}&quot; }, { &quot;{{#each numbers}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{this}}&quot; } } ] } }; Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;items&quot;: [{ &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: 3&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: 1 }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: 2 }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: 3 }] } 5.5.7 Merge You can merge multiple objects into a single object using the #merge operator. If there are any overlapping attributes, the ones that come later will override the previously set attribute. Template and Data var data = { numbers: [1,2,3], align: &quot;right&quot;, size: &quot;14&quot; }; var template = { &quot;{{#merge}}&quot;: [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: {{numbers.length}}&quot; }, { &quot;style&quot;: { &quot;align&quot;: &quot;{{align}}&quot;, &quot;size&quot;: &quot;{{size}}&quot; }, &quot;action&quot;: { &quot;type&quot;: &quot;$render&quot; } } ] }; Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: 3&quot;, &quot;style&quot;: { &quot;align&quot;: &quot;right&quot;, &quot;size&quot;: &quot;14&quot; }, &quot;action&quot;: { &quot;type&quot;: &quot;$render&quot; } } 5.5.8 Inline JavaScript You can use ANY native javascript expression inside the template. Template and Data var template = { &quot;ranking&quot;: { &quot;{{#each players.sort(function(p1, p2) { return p2.quantity - p1.quantity; }) }}&quot;: &quot;{{name}} ate {{quantity}}&quot; }, &quot;winner&quot;: &quot;{{players.sort(function(p1, p2) { return p2.quantity - p1.quantity; })[0].name }}&quot; }; var data = { &quot;players&quot;: [{ &quot;name&quot;: &quot;Alice&quot;, &quot;quantity&quot;: 102 }, { &quot;name&quot;: &quot;Mad Hatter&quot;, &quot;quantity&quot;: 108 }, { &quot;name&quot;: &quot;Red Queen&quot;, &quot;quantity&quot;: 100 }] }; Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;ranking&quot;: [ &quot;Mad Hatter ate 108&quot;, &quot;Alice ate 102&quot;, &quot;Red Queen ate 100&quot; ], &quot;winner&quot;: &quot;Mad Hatter&quot; } 5.5.9 $root Sometimes you need to refer to the root data object while iterating through an #each loop. In this case you can use a special keyword named $root. Template and Data var template = { &quot;{{#each posts}}&quot;: [ &quot;{{content}}&quot;, &quot;{{$root.users[user_id]}}&quot; ] } var data = { users: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;], posts: [{ content: &quot;Show me the money&quot;, user_id: 1 }, { content: &quot;hello world&quot;, user_id: 0 }, { content: &quot;what is the meaning of life?&quot;, user_id: 2 }] } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result [ [&quot;Show me the money&quot;, &quot;Bob&quot;], [&quot;hello world&quot;, &quot;Alice&quot;], [&quot;what is the meaning of life?&quot;, &quot;Carol&quot;] ] 5.5.10 \\(index You can use a special variable named `\\)indexwithin#each` loops. Template and Data const template = { &quot;rows&quot;: { &quot;{{#each items}}&quot;: { &quot;row_number&quot;: &quot;{{$index}}&quot;, &quot;columns&quot;: { &quot;{{#each this}}&quot;: { &quot;content&quot;: &quot;{{this}}&quot;, &quot;column_number&quot;: &quot;{{$index}}&quot; } } } } }; const data = { &quot;items&quot;: [ [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;], [1,2,3,4,5] ] }; const result = ST.select(template) .transform(data) .root() // or // const result = ST.transform(template, data) Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;rows&quot;: [ { &quot;row_number&quot;: 0, &quot;columns&quot;: [ { &quot;content&quot;: &quot;a&quot;, &quot;column_number&quot;: 0 }, { &quot;content&quot;: &quot;b&quot;, &quot;column_number&quot;: 1 }, { &quot;content&quot;: &quot;c&quot;, &quot;column_number&quot;: 2 }, { &quot;content&quot;: &quot;d&quot;, &quot;column_number&quot;: 3 }, { &quot;content&quot;: &quot;e&quot;, &quot;column_number&quot;: 4 } ] }, { &quot;row_number&quot;: 1, &quot;columns&quot;: [ { &quot;content&quot;: 1, &quot;column_number&quot;: 0 }, { &quot;content&quot;: 2, &quot;column_number&quot;: 1 }, { &quot;content&quot;: 3, &quot;column_number&quot;: 2 }, { &quot;content&quot;: 4, &quot;column_number&quot;: 3 }, { &quot;content&quot;: 5, &quot;column_number&quot;: 4 } ] } ] } 5.5.11 Local Variables You can use #let API to declare local variables. The #let API takes an array as a paremeter, which has two elements: The first parameter: the {{#let}} statement which assigns any value to a variable. The second parameter: the actual expression that will be evaluated. Here‚Äôs an example: Template and Data const data = { families: [{ location: &quot;Wonderland&quot;, members: [{ name: &quot;Alice&quot; }, { name: &quot;Bob&quot; }] }, { location: &quot;Springfield&quot;, members: [{ name: &quot;Bart&quot; }, { name: &quot;Marge&quot; }, { name: &quot;Lisa&quot; }, { name: &quot;Homer&quot; }, { name: &quot;Maggie&quot; }] }] } const template = { &quot;rows&quot;: { &quot;{{#each families}}&quot;: { &quot;{{#let}}&quot;: [{ &quot;family_location&quot;: &quot;{{location}}&quot; }, { &quot;{{#each members}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}} in {{family_location}}&quot; } }] } } } Select and Transform const result = ST.select(template) .transform(data) .root() // or // const result = ST.transform(template, data) Result { &quot;rows&quot;: [ [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Alice in Wonderland&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Bob in Wonderland&quot; } ], [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Bart in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Marge in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Lisa in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Homer in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Maggie in Springfield&quot; } ] ] } The local variable feature is important when you are using nested loops. You could use the $root variable to reach out of the current loop context, but this has limitations, because you can always only reach out to the root level. By using the #let API, you can define a variable at any level of a loop and have it accessible from anywhere further down the loop WITHOUT using the $root variable. 5.5.12 Example 1 - Use only a subtree of a template Sometimes you don‚Äôt want to use the entire template to parse data. In this case you can select a subtree of a template and use that to parse data. var template = { body: { sections: [{ items: { &quot;{{#each items}}&quot;: { type: &quot;{{type}}&quot;, url: &quot;{{url}}&quot; } } }] } }; var finalTemplate = ST.select(template, function(key, val) { return key === &#39;type&#39;; }) .transform({ type: &quot;image&quot; }).root(); /* finalTemplate = { body: { sections: [{ items: { &quot;{{#each items}}&quot;: { type: &quot;image&quot;, url: &quot;{{url}}&quot; } } }] } } */ 5.5.13 Example 2 - Filter Data + Transform with template Sometimes you have a large set of data but only want to transform a portion of it. In this case you can select a subtree of the data object and parse using a template. var data = { &quot;item&quot;: { &quot;url&quot;: &quot;http://localhost&quot;, &quot;text&quot;: &quot;localhost&quot; }, &quot;items&quot;: [ { &quot;url&quot;: &quot;file://documents&quot;, &quot;text&quot;: &quot;documents&quot; }, { &quot;url&quot;: &quot;https://blahblah.com&quot;, &quot;text&quot;: &quot;blah&quot; } ], &quot;nestedItems&quot;: { &quot;childItems&quot;: [{ &quot;url&quot;: &quot;http://hahaha.com&quot;, &quot;text&quot;: &quot;haha&quot; }, { &quot;url&quot;: &quot;https://hohoho.com&quot;, &quot;text&quot;: &quot;hoho&quot; }] } }; var selection = ST.select(data, function(key, val) { return key === &#39;url&#39;; }); var urls = selection.values(); /** * urls = [ * &quot;http://localhost&quot;, * &quot;file://documents&quot;, * &quot;https://blahblah.com&quot;, * &quot;http://hahaha.com&quot;, * &quot;https://hohoho.com&quot; * ] */ var transformed = selection.transformWith({ &quot;tag&quot;: &quot;&lt;a href=&#39;{{url}}&#39;&gt;{{text}}&lt;/a&gt;&quot; }) var objects = transformed.objects() /** * objects = [ * { &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } * ] */ var values = transformed.values() /** * values = [ * &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;https://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; * ] */ var keys = transformed.keys() /** * keys = [&quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;] */ var root = transformed.root() /** * root = { * &quot;item&quot;: { * &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; * }, * &quot;items&quot;: [ * { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; }, * ], * &quot;nestedItems&quot;: { * &quot;childItems&quot;: [ * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } * ] * } * }; */ var transformed = ST.select({ &quot;{{#each items}}&quot;: { tag: &quot;&lt;a href=&#39;{{url}}&#39;&gt;{{text}}&lt;/a&gt;&quot; } }).transform({ items: urls }); var root = transformed.root(); /* root = { &quot;item&quot;: { &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; }, &quot;items&quot;: [ { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; } ], &quot;nestedItems&quot;: { &quot;childItems&quot;: { &quot;tag&quot;: &quot;&lt;a href=&#39;http://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } } */ var keys = transformed.keys(); /* keys = [&quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;]; */ var values = transformed.values(); /* values = [ &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;http://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; ] */ var objects = transformed.objects(); /* objects = [ { &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;http://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } ] */ var paths = transformed.paths(); 5.5.14 Example 3 - Nesting Templates Sometimes you may want to reuse a template by nesting inside another template. In this case you just need to select a subtree of the parent template and plug in a child template. var data = { &quot;item&quot;: { &quot;url&quot;: &quot;http://localhost&quot; }, &quot;items&quot;: [ { &quot;url&quot;: &quot;file://documents&quot; }, { &quot;url&quot;: &quot;https://blahblah.com&quot; } ], &quot;nestedItems&quot;: { &quot;childItems&quot;: [{ &quot;url&quot;: &quot;http://hahaha.com&quot;, &quot;text&quot;: &quot;haha&quot; }, { &quot;url&quot;: &quot;https://hohoho.com&quot;, &quot;text&quot;: &quot;hoho&quot; }] } }; var template = { &quot;items&quot;: { &quot;{{#each items}}&quot;: &quot;{{partial}}&quot; } } var partial = { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } var selected = ST.select(template, function(key, val) { return val === &#39;{{partial}}&#39;; }) var finalTemplate = selected.transform({ &quot;partial&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } }).root(); /* finalTemplate = { &quot;items&quot;: { &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } } } */ 5.6 Examples 5.6.1 Declarative JSON API Template Build JSON using a simple, human-readable, and declarative template instead of manually coding it. See the example code at: https://github.com/jasonelle/st.js-api.template Old way: Manually construct object // app.js app.get(&#39;/&#39;, function (req, res) { var response = {} response[&quot;current_user&quot;] = { username: &quot;@&quot; + req.user.username, firstname: req.user.name.split(&#39; &#39;)[0], lastname: req.user.name.split(&#39; &#39;)[1] } var transformed_posts = db.posts.map(function(post){ return { slug: post.slug permalink: &quot;https://blahblahblah.blahblah/&quot; + post.slug, post_title: post.title, post_content: post.content } }) response[&quot;posts&quot;] = transformed_posts res.json(response) }) New way: Declarative approach with ja.js // app.js app.get(&#39;/&#39;, function (req, res) { res.json(ST.select(require(&#39;./template.json&#39;)) .transform({user: req.user, posts: db.posts}) .root()) }) // template.json { &quot;current_user&quot;: { &quot;username&quot;: &quot;@{{user.username}}&quot;, &quot;firstname&quot;: &quot;{{user.name.split(&#39; &#39;)[0]}}&quot;, &quot;lastname&quot;: &quot;{{user.name.split(&#39; &#39;)[1]}}&quot; }, &quot;posts&quot;: { &quot;{{#each posts}}&quot;: { &quot;slug&quot;: &quot;{{slug}}&quot;, &quot;permalink&quot;: &quot;https://blahblahblah.blahblah/{{slug}}&quot;, &quot;post_title&quot;: &quot;{{title}}&quot;, &quot;post_content&quot;: &quot;{{content}}&quot; } } } 5.6.2 JSON as a JSON Query Language Make complex API queries purely written in JSON. Since templates in ST are written in JSON, you can pass them around anywhere just like any other data object. Notice we‚Äôre not creating some new query language, it‚Äôs just JSON. No convoluted infrastructure to set up! See the example code at: https://github.com/jasonelle/st.js-jsonql 5.6.3 App as data Templates are normally used for views But the cool thing about JSON is it can be used to declaratively represent ANYTHING from Model to View to Controller. What if we set executable functions as leaf nodes of an object, select &amp; transform it, and then auto-trigger the resolved function? We have built a router in JSON! Basically, the entire router logic is represented as a piece of data. Browser var rpc = { name: &quot;add&quot;, args: [2,3,1] } fetch(&quot;http://localhost:3000&quot;, { method: &quot;POST&quot;, headers: { &#39;Accept&#39;: &#39;application/json&#39;, &#39;Content-Type&#39;: &#39;application/json&#39; }, body: JSON.stringify(rpc) ).then(function(res) { console.log(res.json()); }) Server // router.json [{ &quot;{{#if &#39;name&#39; in this}}&quot;: [{ &quot;{{#if name === &#39;add&#39;}}&quot;: &#39;add_service&#39; }, { &quot;{{#elseif name === &#39;subtract&#39;}}&quot;: [{ &quot;{{#if args.length === 2}}&quot;: &#39;subtract_service&#39; }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }] }] }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }] // express server app.post(&#39;/&#39;, (req, res) =&gt; { const Services = { add_service: function(){ return Array.prototype.slice .call(arguments) .reduce((a,b) =&gt; { return a+b; }, 0) }, subtract_service: function() { return arguments[0] - arguments[1] }, error_service: function() { return &#39;error&#39;; } } const name = ST.transform(require(&#39;./router.json&#39;), req.body); res.json(Services[name].apply(this, req.body.args)); }); 5.6.4 Routerless Server Let‚Äôs take the router example from right above. Since our router logic is just a JSON (router.json), we don‚Äôt even need it on the server side. What if we DON‚ÄôT keep router.json on the server, but send it from the browser? Browser var router = [{ &quot;{{#if &#39;name&#39; in this}}&quot;: [{ &quot;{{#if name === &#39;add&#39;}}&quot;: &#39;add_service&#39; }, { &quot;{{#elseif name === &#39;subtract&#39;}}&quot;: [{ &quot;{{#if args.length === 2}}&quot;: &#39;subtract_service&#39; }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }] }] }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }]; var rpc = { name: &quot;add&quot;, args: [2,3,1], router: router } fetch(&quot;http://localhost:3000&quot;, { method: &quot;POST&quot;, headers: { &#39;Accept&#39;: &#39;application/json&#39;, &#39;Content-Type&#39;: &#39;application/json&#39; }, body: JSON.stringify(rpc) ).then(function(res) { console.log(res.json()); }) Server // express server app.post(&#39;/&#39;, (req, res) =&gt; { const Services = { add_service: function(){ return Array.prototype.slice .call(arguments) .reduce((a,b) =&gt; { return a+b; }, 0) }, subtract_service: function() { return arguments[0] - arguments[1] }, error_service: function() { return &#39;error&#39;; } } const name = ST.transform(req.body.router, req.body); res.json(Services[name].apply(this, req.body.args)); }); What‚Äôs going on here? We are looking at a server WITHOUT a router. Instead of implementing a router on the server, we send the router itself as part of a network request! This type of JSON-powered portability provides extreme flexibility when creating interfaces for microservices and RPC endpoints Also, remember that you can bake validation, conditionals, loops, etc. all in a single JSON IPC/RPC call, which makes it extremely powerful and efficient. 5.6.5 Jasonette Jasonette uses ja.js to: Transform an ‚Äúaction‚Äù JSON object into a native method call. Transform any client-side data into a view markup, and then into actual native view components. Here‚Äôs an example where we describe an ‚Äúaction‚Äù (function) in a JSON object: { &quot;type&quot;: &quot;$network.request&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;https://jsonplaceholder.typicode.com/posts&quot; }, &quot;success&quot;: { &quot;type&quot;: &quot;$render&quot;, &quot;options&quot;: { &quot;data&quot;: &quot;{{$jason}}&quot; } } } Every function (called ‚Äúaction‚Äù) consists of up to four attributes: &quot;type&quot;: Type of action to perform. Jasonette interprets this into an actual native method call. &quot;options&quot;: Arguments to send to the action. &quot;success&quot;: Success callback. You can chain another action here. &quot;error&quot;: Error callback. You can chain another action here. In above example we make a &quot;$network.request&quot; action call, with a payload of: &quot;options&quot;: { &quot;url&quot;: &quot;https://jsonplaceholder.typicode.com/posts&quot; } This actually translates to a native Objective-c function call, and when it succeeds, it triggers its ‚Äúsuccess‚Äù callback which is another action: &quot;success&quot;: { &quot;type&quot;: &quot;$render&quot;, &quot;options&quot;: { &quot;data&quot;: &quot;{{$jason}}&quot; } } This is where ja.js comes in. Whenever an action call is made, Jasonette automatically fills the $jason variable with the return value from its preceding action ($network.request) and runs a transform, thereby implementing an actual function call. "],
["tools.html", "6 Tools 6.1 Jason App { ¬∑·¥•¬∑}", " 6 Tools The following tools help developers to be more efficient in using Jasonette technology. 6.1 Jason App { ¬∑·¥•¬∑} Jason is a single app that lets you summon and bookmark multiple Jasonette apps simply by entering the JSON url, without building your own physical app or setting up development environment. It‚Äôs good for using as a container for single purpose apps or quick disposable apps, prototyping, beta testing, etc. 6.1.1 How is related to Jasonette? Maybe it‚Äôs easier if we put it this way: Jason { ¬∑·¥•¬∑} is like a Web browser, Jasonette { ÀÉÃµÃë·¥•ÀÇÃµÃë} is the Web browser‚Äôs engine. 6.1.2 What is it? Jason is an app that lets you bookmark and run multiple Jasonette apps without building your own. Jason itself is built with Jasonette. Jasonette is the open source app framework that lets you build your own publishable app. 6.1.3 When to use? When you need to‚Ä¶ Jason Start building without a development environment like XCode or Android Studio. Useful for quick prototyping. Beta test your Jasonette app with friends before submitting to the app store. Just need to share URL. Bookmark and run multiple Jasonette apps from a single app. Build apps that can‚Äôt be / don‚Äôt need to be published to the App Store Disposable apps, private apps. Jasonette When you need to package up an app so you can publish to the App Store. 6.1.4 How to Install Installing Jason App is similar to creating a custom Jasonette App. The main difference is that you only made this once and you will be ready to start testing your JSONs. Download Jasonette from the releases repository (https://github.com/jasonelle/jasonelle/releases). Add the Jason url to the project. Build it in XCode or Android Studio. The url you must use is https://raw.githubusercontent.com/jasonelle/docs/develop/examples/jasonette/apps/jason-app/index.json Jason App in Xcode The complete source code is in the following directory https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/jason-app If you need futher documentation please visit the old docs setup guide. https://jasonelle.com/jasonette-old-docs/ios/ https://jasonelle.com/jasonette-old-docs/android/ 6.1.5 How to Use Once you installed Jason App in your device, start adding the URLs that contains a valid JSON App. You can use this by typing the url or scaning a Qr code image. "],
["jasonette-tutorials.html", "7 Jasonette Tutorials 7.1 Build a QRCode/Barcode scanning app with 26 lines of JSON 7.2 Turn Your Website into a Mobile App with 7 Lines of JSON", " 7 Jasonette Tutorials The following tutorials are using Jasonette as the main technology. 7.1 Build a QRCode/Barcode scanning app with 26 lines of JSON This tutorial was posted by Ethan on Medium Nowadays we see QR code everywhere. We see it on a billboard, we see it embedded in product packaging, we use it to share Bitcoin public key. QR code is like a 2D version of barcode. As a publisher, you can pack all kinds of data in it as an image, and as a consumer you can simply scan the QR code to extract whatever is stored in the code. Both web.jasonette.com and jasonbase.com websites incorporate QR Code scanning, so you can just open your JASON app and scan the QR code to automatically open the app. Scan the QR code from JASON app to load the app But you can do much more than just storing a URL in a QR code. Let‚Äôs take a look at how you can implement the QR code feature for your app too. Like any other features on Jasonette, it‚Äôs all built into Jasonette, so you don‚Äôt need to do anything. You just need to load a JSON markup that instructs Jasonette to scan QR code. 7.1.1 How to implement You can implement barcode &amp; QR code scanning using a newly added API called $vision. Here‚Äôs how you implement them: 1 - Include back facing camera as background, as follows: { &quot;$jason&quot;: { &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 2 - Wait for $vision.ready event and call $vision.scan action You need to wait for the camera to be ready before calling the scan action. { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$vision.ready&quot;: { &quot;type&quot;: &quot;$vision.scan&quot; } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 3 - Now wait for $vision.onscan event This will be triggered once when the camera scans a new barcode. The event will return the data inside $jason, which you can parse to use it for your own purpose, like below: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$vision.ready&quot;: { &quot;type&quot;: &quot;$vision.scan&quot; }, &quot;$vision.onscan&quot;: { &quot;type&quot;: &quot;$util.alert&quot;, &quot;options&quot;: { &quot;title&quot;: &quot;Scanned&quot;, &quot;description&quot;: &quot;{{$jason.content}}&quot; } } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 7.1.2 Simple and Flexible, works on both iOS and Android. Believe it or not, I have just introduced you to the entirety of the $vision API. No need to write native code or install additional features, it‚Äôs already all built into Jasonette-iOS and Jasonette-Android. Just load the JSON markup from Jasonette and it should just work. This works not just for the QR code, but also for regular ‚Äúone dimensional‚Äù barcode we‚Äôre all familiar with. Just like any other Jasonette actions, you can chain the scanned data with other Jasonette action to achieve whatever you need to build. For example you could: Automatically open a web page by scanning a QR code containing a URL Render any UI component using $render and passing the scanned data to a template. etc. Below you see another example which scans barcode and qrcode, and displays the content on the screen in realtime: Check out the code for above example in Jasonpedia. 7.1.3 Conclusion QR code is really cool, and Jasonette makes it super easy to implement it just by writing a few lines of JSON markup. Not only is it easy, but it‚Äôs also very flexible, since you can pass the return value to any other action to build whatever you want. Please play with it and share if you come up with any cool examples. Have fun! 7.2 Turn Your Website into a Mobile App with 7 Lines of JSON A New Approach for Blending Web Engine into Native Apps This tutorial was posted by Ethan on FreeCodeCamp. What if I told you the 7 lines of JSON above, colored in orange is all you need to turn a website into a mobile app? No need to rewrite your website using some framework API just to make it behave like a mobile app. Just bring your existing website as is, and blend it into a native app with a simple URL reference. And what if, just by tweaking the JSON markup a bit, you can access all the native APIs, native UI components, as well as native view transitions out of the box? Here‚Äôs what a minimal example looks like in action: Notice how I‚Äôve embedded a github.com web page but the rest of the layout is all native UI components, such as the navigation header and the bottom tab bar. And the transition is automatically native without you having to rewrite the website using any APIs. Before I explain how, you may ask: ‚ÄúThat‚Äôs cool, but can you do anything meaningful other than just displaying the web page in a native app frame?‚Äù Great question, because that‚Äôs the main topic of this post. All you need to do is create a seamless 2-way communication channel between the web view and the app, so the parent app can trigger any JavaScript functions inside the web view and the web view can reach outside to call native APIs. Here‚Äôs one such example: Note that this view contains: Native navigation header, complete with built-in transition functionality A Web view, which embeds a QR code generator web app A native chat input component at the bottom All this can be described by just tweaking some of the JSON markup attributes we saw above. Finally, note that the QR code changes as you enter something from the chat input. The chat input triggers a JavaScript function inside the QR code web app that re-generates the image. No app development framework has tried to fundamentally solve this problem of ‚Äúseamless integration of web view into native apps‚Äù because they‚Äôre all focused on picking either 100% native or 100% HTML5 side. Whenever you hear someone talk about the future of mobile apps, you would probably hear them talk about ‚ÄúWill it be the HTML5 approach that wins out? Or will it be native?‚Äù. None of them see native and html as something that could co-exist and furthermore, create synergy and achieve things that are not easily possible otherwise. In this article I‚Äôm going to explain: Why blending web engine and native components is often a good idea. Why a seamless integration of HTML and Native is not easy, and how I implemented one. Most importantly, how YOU can use it to build your own app instantly. 7.2.1 Why would you use HTML in a native app? Before we go further, let‚Äôs first discuss whether this is even a good idea, and when you may want to take this approach. Here are some potential use cases: Use Web Native Features Some parts of your app may be better implemented using the web engine. For example, Websocket is a web-native feature that‚Äôs designed for the web environment. In this case it makes sense to use the built-in web engine (WKWebView for iOS and WebView for Android) instead of installing a 3rd party library that essentially ‚Äúemulates‚Äù Websocket. No need to install additional code just to do something that you can do for free, which brings us to the next point. Avoid Large Binary Size You may want to quickly incorporate features that will otherwise require a huge 3rd party library. For example, to incorporate a QR code image generator natively, you will need to install some 3rd party library which will increase the binary size. But if you use the web view engine and a JavaScript library through a simple &lt;script src&gt;, you get all that for free, and you don‚Äôt need to install any 3rd party native libraries. No Reliable Mobile Library Exists For some cutting edge technologies, there is no reliable and stable mobile implementation yet. Fortunately most of these technologies have web implementations, so the most efficient way to integrate them is to use their JavaScript library. Build part-native, part-web-based apps Many new developers looking to port their website into a mobile app get discouraged or overwhelmed when they find out some of their existing website features are too complex to quickly rewrite from scratch for each mobile platform. For example, you may have a single web page that‚Äôs too complex to immediately convert to a mobile app, but the rest of your website may be easily converted. In this case, it would be nice if there was a way to build most of the app natively, but for that particular complex web page, somehow seamlessly integrate it into the app as HTML. 7.2.2 How does it work? Jasonette Jasonette is an open source, markup-based approach to building cross-platform native apps. It‚Äôs like a web browser, but instead of interpreting HTML markup into web pages, it interprets JSON markup into native apps on iOS and Android. Just like how all web browsers have exactly the same code but can deliver you all kinds of different web apps by interpreting various HTML markup on demand, all Jasonette apps have exactly the same binary, and it interprets various JSON markup on demand to create your app. The developers never need to touch the code. Instead, you build apps by writing a markup that translates to native app in real-time. You can learn more about Jasonette here. While Jasonette at its core is all about building native apps, this particular article is about integrating HTML into the core native engine, so let‚Äôs talk about that. Jasonette Web Container Native apps are great but sometimes we need to make use of web features. But integrating web views into a native app is a tricky business. A seamless integration requires: Web view should be integrated as a part of native layout: The web view should blend into the app as a part of the native layout and is treated just like any other native UI components. Otherwise it will feel clunky, and it will feel exactly like what it is a website. Parent app can control child web container: The parent app should be able to freely control the child web view. Child web container can trigger native events on the parent app: The child app should be able to trigger the parent app‚Äôs events to run native APIs. These are a lot of work, so I first worked on only the first piece of the puzzle simply embedding a web container into native layout and released it as version 1. This was already pretty useful, but it still had the limitation of being non-interactive. The parent app couldn‚Äôt control the child web container, and the child couldn‚Äôt notify the parent of any event, keeping the web container completely isolated from the outside world. Jasonette Web Container 2.0: Make it Interactive After releasing version 1, I experimented with the second piece of the puzzle adding interactivity to the web container. The next section explains the solutions that were added to make the previously-static web containers interactive, making them significantly more powerful. 7.2.3 Implementation: Interactive Web Container 1 - Load by URL Problem Previously in version 1, to use web container as a background view component, you had to first set the $jason.body.background.type to &quot;html&quot; and then hard-code the HTML text under $jason.body.background.text attribute like this: { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;text&quot;: &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; } } } } Naturally people wanted to be able to instantiate the container using simply a web URL instead of having to hardcode the entire HTML text in a single line. Solution Web container 2.0 has added the url attribute. You can embed a local file:// HTML like this (it loads from the local HTML file you ship with the app): { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot; } } } } Or embed a remote http[s]:// URL like this (it loads from a remote HTML): { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;https://news.ycombinator.com&quot; } } } } 2 - Parent App &lt;=&gt; Web Container Communication Problem Previously, web containers were only for displaying content, and not interactive. This meant NONE of the following was possible: Jasonette =&gt; Web Container: Call JavaScript functions inside the web container from Jasonette. Web Container =&gt; Jasonette: Call native API from web container code. All you could do was display the web container. This was similar to how you would embed an iframe in a web page, but the main web page had no access to what was inside the iframe. Solution The whole point of Jasonette is to design a standard markup language to describe cross platform mobile apps. In this case, we needed a markup language that could comprehensively describe communications between the parent app and the child web container. To achieve this, I came up with a JSON-RPC based communication channel between the parent app and the child web container. Since everything on Jasonette is expressed in JSON objects, it made perfect sense to use the JSON-RPCstandard format as the communication protocol. To make a JavaScript function call into the web container, we declare an action called $agent.request: { &quot;type&quot;: &quot;$agent.request&quot;, &quot;options&quot;: { &quot;id&quot;: &quot;$webcontainer&quot;, &quot;method&quot;: &quot;login&quot;, &quot;params&quot;: [&quot;username&quot;, &quot;password&quot;] } } $agent.request is the native API that triggers a JSON-RPC request into the web container. To use it, we must pass an options object as its parameter. The options object is the actual JSON-RPC request that will be sent to the web container. Let‚Äôs look at what each attribute means: id: Web container is built on top of a lower level architecture called agent. Normally you can have multiple agents for a single view, and each agent can have its unique ID. But Web container is a special type of agent which can only have the id of $webcontainer, which is why we use that ID here. method: The JavaScript function name to call. params: The array of parameters to pass to the JavaScript function. The full markup would look something like this: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$load&quot;: { &quot;type&quot;: &quot;$agent.request&quot;, &quot;options&quot;: { &quot;id&quot;: &quot;$webcontainer&quot;, &quot;method&quot;: &quot;login&quot;, &quot;params&quot;: [&quot;alice&quot;, &quot;1234&quot;] } } } }, &quot;body&quot;: { &quot;header&quot;: { &quot;title&quot;: &quot;Web Container 2.0&quot; }, &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot; } } } } This markup is saying: When the view loads ($jason.head.actions.$load), make a JSON-RPC request into the web container agent ($agent.request) where the request is specified under options. The web container is defined under $jason.body.background, which in this case loads a local file called file://index.html. It will look for a JavaScript function called login and pass the two arguments under params ( &quot;alice&quot; and &quot;1234&quot;). login(&quot;alice&quot;, &quot;1234&quot;) I‚Äôve only explained how the parent app can trigger the child web container‚Äôs JavaScript function calls, but you can also do the opposite and let the web container trigger the parent app‚Äôs native API. To learn more, check out the agent documentation. Example Let‚Äôs come back to the QR code example I briefly shared above: The footer input component is 100% native. The QR code is generated by the web container as a web app. When a user enters something and presses ‚ÄúGenerate,‚Äù it calls $agent.request action into the web container agent, calling the JavaScript function ‚Äúqr‚Äù. You can check out the example here. 3 - Script Injection Problem Sometimes you may want to dynamically inject JavaScript code into the web container AFTER it‚Äôs finished loading the initial HTML. Imagine you want to build a custom web browser app. You may want to inject your own custom JavaScript into every web view to customize the web view‚Äôs behavior, kind of like how web browser extensions work. Even if you‚Äôre not building a web browser, you may want to use the script injection method whenever you want a custom behavior for a URL whose content you have no control over. The only way to communicate between the native app and the web container is through the $agent API. But if you can‚Äôt change the HTML content, the only way to add the $agent interface into the web container is through dynamic injection. Solution As mentioned in the previous section, the $jason.body.background web container is just another agent. This means you can use the same $agent.inject method available to regular agents. 4 - URL Click Handling In the past, there were only two ways a web container could handle link clicks: Readonly: Treat the web container as readonly and ignore all events such as touch or scroll. All web containers are readonly unless you tell them to behave like a regular browser, as described below. Regular Browser Behavior: Let users interact with the page by behaving like a normal browser. You declare it by setting &quot;type&quot;: &quot;$default&quot; as its action attribute. Problem Both are ‚Äúall or nothing‚Äù solutions. In the ‚ÄúReadonly‚Äù case, all your interactions are completely ignored by the web container. In the ‚ÄúRegular Browser Behavior‚Äù case, the web container functions literally as a browser. When you click a link, it would just send you to that link by refreshing the page just like a web page. There was no way to hijack the click and call some native API. Solution With the new web container, you can now attach any action on the $jason.body.background web container to handle link click events. Let‚Äôs look at an example: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;displayBanner&quot;: { &quot;type&quot;: &quot;$util.banner&quot;, &quot;options&quot;: { &quot;title&quot;: &quot;Clicked&quot;, &quot;description&quot;: &quot;Link {{$jason.url}} clicked!&quot; } } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;displayBanner&quot; } } } } } Here we have attached &quot;trigger&quot;: &quot;displayBanner&quot; to the web container. This means that when a user clicks any link in the web container, it will trigger displayBanner action instead of letting the web view handle it. Also, if you look at the displayBanner action, you‚Äôll notice the $jason variable. In this case, the clicked link will be passed through the $jason variable. For example, if you clicked a URL named &quot;https://google.com&quot;, the $jason will have the following value: { &quot;url&quot;: &quot;https://google.com&quot; } This means you can selectively trigger different actions by checking the $jason.url value. Let‚Äôs take another example where we implement a custom web browser: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;handleLink&quot;: [{ &quot;{{#if $jason.url.indexOf(&#39;signin&#39;) !== -1 }}&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;file://key.html&quot; } } }, { &quot;{{#else}}&quot;: { &quot;type&quot;: &quot;$default&quot; } }] } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;handleLink&quot; } } } } } We test if the URL contains the string signin and then run two different actions depending on the result. If it contains signin, it opens a new view to take care of signing in natively. If it doesn‚Äôt contain signin, just run the &quot;type&quot;: &quot;$default&quot; action so that it behaves like a regular browser. 7.2.4 Example Usage Building a custom web browser We can now take advantage of the fact that the new web container can: Take a url attribute to load itself, functioning as a full-fledged browser Selectively handle link clicks depending on the URL We can even build a custom web browser app with just a dozen lines of JSON. Since we can now hijack every link click, we can take a look at $jason.url and run whatever actions we want depending on the URL. For example, take a look at the example below: On the left side we see that clicking a link behaves like a regular browser (&quot;type&quot;: &quot;$default&quot;) On the right side we see that clicking a link does a native transition to another JASON view. All this can be achieved by selectively triggering different actions based on $jason.url. Step 1. Attach an action named visit to the web container like this: { ... &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;https://news.ycombinator.com&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;visit&quot; } } } } Step 2. Run relevant actions inside visit, based on $jason.url In the following code, we‚Äôre checking if $jason.url matches newest, show, ask, and so on (they‚Äôre the top menu item links). If they do, we let the web container behave like a regular browser by setting &quot;type&quot;: &quot;$default&quot;. If they don‚Äôt match the pattern, we make a native $href transition to a new view and pass the clicked link as a parameter. ... &quot;actions&quot;: { &quot;visit&quot;: [ { &quot;{{#if /\\\\/(newest|show|ask)$/.test($jason.url) }}&quot;: { &quot;type&quot;: &quot;$default&quot; } }, { &quot;{{#else}}&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;https://jasonette.github.io/Jasonpedia/webcontainer/agent/hijack.json&quot;, &quot;preload&quot;: { &quot;background&quot;: &quot;#ffffff&quot; }, &quot;options&quot;: { &quot;url&quot;: &quot;{{$jason.url}}&quot; } } } } ] }, Check out the full JSON markup for the web browser here (it‚Äôs only 48 lines!). Instant ‚ÄúHybrid‚Äù App When people normally talk about ‚Äúhybrid‚Äù apps, they mostly mean HTML web apps wrapped inside a native app frame. But that‚Äôs not what I mean here. When I say ‚ÄúHybrid,‚Äù I mean a truly hybrid app, where one app can have multiple native views and multiple web-based views simultaneously. Also where one view can have multiple native UI components and a web container rendered in the same native layout. The cross-over between web-based view and native view should be so seamless that it‚Äôs hard to tell where one starts and ends. In this example, I‚Äôve created an app that displays jasonbase.com in a web container as the home view. Jasonbase is a free JSON hosting service I built to easily host JSON markup for Jasonette apps. Naturally, it‚Äôs just a website, but I have embedded it in Jasonette so that when you click the link, instead of opening a web page, it makes a native $href transition to a native JASON view. I didn‚Äôt have to touch any of Jasonbase.com‚Äôs code to build this app. I simply embedded the website into Jasonette as a web container, and hijacked the link clicks to handle them natively, so it can do all the native stuff like triggering native APIs and making native transitions. You can check out the code here. 7.2.5 Conclusion In my opinion, what makes all this work fabulously is that everything is taken care of on the framework level. All the hard work is taken care of behind the scenes. Instead of putting the burden on the app developers to implement all of the following from scratch: Embed a webview into native layout. Create a JavaScript bridge so the app can make function calls into the web view. Creating a native event handling architecture so the web view can trigger native events on the parent app. The solution was to create an abstraction made up of: Declarative Markup Language: for describing how to embed a web view into a native app. Communication Protocol (JSON-RPC): to allow dead-simple interactions between the app and its child web views. I don‚Äôt claim this approach to be the ultimate solution to solve everything, but I‚Äôm happy to say that this has been a great solution for my own use case. I was trying to build an app that builds on a super edge technology which has no stable and reliable mobile implementations (and it‚Äôs not clear if there ever will be a mobile implementation due to the protocol‚Äôs nature). Thankfully it had JavaScript implementations so I could easily integrate it into the app without hassle. Overall, it‚Äôs been great and I‚Äôm satisfied with how it turned out. The documentation is up to date to reflect all the new features, so feel free to dig in and play around. Disclaimer: With great power comes great responsibility I would like to end with a disclaimer: as great as this newly found power is, I think you need to keep a balance to build an app with a great user experience. Some may take this and build an entire app using web views only, but then you will end up with an app that‚Äôs basically just a website, which defeats the purpose of building a dedicated app. I emphasize that I‚Äôm not saying you should always build apps with both HTML and native. I am saying this can be very useful for many people in different situations. Just don‚Äôt go overboard with it. Follow Along to Learn More There are many different configurations in which the Jasonette native core and its child web container can communicate to get things done in creative and powerful ways, and this post is just scratching the surface. "],
["how-to-guides.html", "8 How To Guides", " 8 How To Guides "],
["discussions.html", "9 Discussions 9.1 BeerJS - Chile - 2019", " 9 Discussions Discussions and related info is dedicated to index and store links and other resources. 9.1 BeerJS - Chile - 2019 June 5th 2019, was made a presentation of Jasonelle in Santiago, Chile. The presentation slides and related code is stored in the following repository: https://github.com/jasonelle/beerjs "]
]
