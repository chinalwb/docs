[
["index.html", "Jasonelle Documentation 1 Welcome 1.1 Main Goals 1.2 Cool things about Jasonelle 1.3 Old Docs 1.4 Examples 1.5 Why JSON? 1.6 Usable Apps in 100 years!", " Jasonelle Documentation Jasonelle Team 2019-07-25 1 Welcome Jasonelle is a declarative language that takes a JSON markup and turns it into Android/iOS native components and function calls, which then can be packaged and distributed as your own app. And the most important part: it‚Äôs 100% open source under MPL-2.0 license, which means you can take it and build your app, submit it to the App Store, and do whatever you want with it!. It‚Äôs designed to let non-technical and technical users combine hand-coded json/javascript seamlessly into a working native mobile application. 1.1 Main Goals Jasonelle project want to reach these goals: Use known and popular technologies (JSON, Javascript). üíØ Easy to learn, use and extend. ‚ò∫Ô∏è Stable API. ‚öì Use Native Components. üì± Great Documentation. üìù Friendly and Welcoming Community. ü§ù A technology that could be used in 100 years. üï∞Ô∏è 1.2 Cool things about Jasonelle 100% NATIVE: Jasonelle maps JSON into native components and native function calls. There is no gimmick. There is no magic. App loads over HTTP (or local file): Your app exists 100% as JSON, and loads from the cloud or local. No more hard-coding. Send Native App over HTTP Anything that can be expressed in JSON can be sent over the Internet. Anything that can be sent over the Internet doesn‚Äôt need to be on the client. Since Jasonette lets you express the app 100% in JSON, you don‚Äôt need to hard-code your app on the phone anymore. Instead, the app loads directly from the server everytime a user opens the app. An app in 30 minutes: No kidding, build an app in 30 minutes. Describe instead of programming. Instead of writing and compiling complex program lines, you only need to write a single markup that describes what the view should look like and how it should behave. An app that used to take days to build can be built in 30 minutes (or less). Lowest possible learning curve: No programming experience required. There‚Äôs a small amount of things you need to know: JSON (And maybe a little JavaScript). Which means you can build an app without ‚Äúbecoming a programmer‚Äù. Minimum learning curve You can describe the view layout (like HTML), component style (like CSS), and native function calls (like Javascript) ALL in JSON. All you need is a single JSON. 1.3 Old Docs The previous version of this documentation is present in the following url https://jasonelle.com/jasonette-old-docs/. The vast mayority of the old docs are still valid and useful. 1.4 Examples Plenty of code examples are stored in the https://github.com/jasonelle/docs/tree/develop/examples/jasonette repository. 1.5 Why JSON? Industry Standard, lightweight data-interchange format. Huge amount of programming languages and tools with support available. It is easy for humans to read and write. It is easy for machines to parse and generate. A single plain text file can contain all the data and logic needed in a complete native app. You can use any backend to generate the app (or do not use a backend at all). Example: Masonite, ProcessWire, Express, SailsJS, Laravel, Rails, Flask, Django, AWS Lambda, file:// local file. 1.6 Usable Apps in 100 years! Thanks to Jasonelle‚Ñ¢Ô∏è‚Äôs JSON technology Ô∏è you have all the tools needed to create agnostic mobile apps. This means if your app contains only static assets (audio, images, js, jsons, no server) and an interpreter exists in 100 years, your app will be valid and usable!. You can create mobile apps that stands the test of time, apps that does not depends on Apple or Google ecosystems to be executed. Apps that can be used by the next generation of people, even after you leave this dimension!. More details here : https://jasonelle.com/docs/discussions.html#apps-for-a-lifetime. "],
["history.html", "2 History", " 2 History Jasonette was created by ‚ÄúEthan Gliechtenstein‚Äù, a New York developer. Probably from Bushwick. Who‚Äôs real identity nobody knows. Jasonette core began in Late 2014 as an app named ‚ÄúEthan‚Äù (http://www.textethan.com/) It got quickly popular. Ethan App Homepage Tech Crunch https://techcrunch.com/2014/10/30/meet-samantha-ethan-apps-sister/ Ny Times https://www.nytimes.com/2014/12/18/style/ethan-siri-meets-dr-phil.html The Guardian https://www.theguardian.com/technology/2014/dec/04/-sp-ten-best-messaging-apps CNN http://www.cnn.com/2014/10/11/tech/askethan-app Spiegel http://www.spiegel.de/netzwelt/apps/ask-ethan-app-beantwortet-fragen-der-nutzer-a-997335.html Dazed Digital http://www.dazeddigital.com/artsandculture/article/22152/1/this-irl-siri-app-wants-to-answer-all-your-burning-questions Business Insider http://www.businessinsider.com/ethan-is-the-top-app-on-product-hunt-2014-10 SFGate http://www.sfgate.com/business/article/Stupid-apps-but-not-always-a-stupid-idea-5843629.php Ethan App Screenshot If you want to see the prototype Jasonette JSON syntax, see the archived repo here: https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/archived-ethan-app Some time after that Ethan began extracting the core, refining the api and creating documentation. First released Jason App on May 17th 2016 and finally releasing the first version of Jasonette on November 3th 2016. Ethan: I found that it takes too much effort going from having an idea to building an app and having the world use it. I wanted a way to have an idea, turn it into a fully functional native app, and share it with the world, all in the next 10 minutes, almost like writing a blog post. That‚Äôs why I built Jason. Jason is a completely hackable iOS client that does what you tell it to do. You just write a script in JSON and load it from Jason. Jason then interprets it in realtime and turns it into a native app. https://www.producthunt.com/gliechtenstein https://www.producthunt.com/posts/jason https://www.producthunt.com/posts/jasonette https://twitter.com/jasonclient/status/794175517763272708 Jasonette First Tweet Ethan worked on Jasonette, Cell and ST for nearly 2 years straight full-time. Until June 9 2018 were he misteriosly disappeared without a trace. Later on November 6th 2018. Jasonelle Team took the lead (https://github.com/Jasonette/Jasonette/issues/23). Last known Ethan contribution The original repositories of Jasonette, Cell and ST are: https://github.com/jasonette https://github.com/intercellular https://github.com/selecttransform PD: If you want to know that character Ethan uses it‚Äôs Kon from Bleach üíØ (http://bleach.wikia.com/wiki/Kon) "],
["jasonelle-team.html", "3 Jasonelle Team 3.1 Members 3.2 Roles 3.3 How to Join? 3.4 Contributions 3.5 Support", " 3 Jasonelle Team Jasonelle Team consist of different people that shares the following vision: Forge a technology that lowers the barriers for mobile app creation. And those apps could still be used in 100 years or more. 3.1 Members 3.1.1 Active Members Name Photo Role Years CLSource Fire Keeper 2018 - present Pantorozo Forgemaster (Android) 2019 - present 3.1.2 Retired Members Jasonelle Team is grateful for the contribution of the following people: Name Photo Role Years Ethan Prometheus 2016 - 2018 3.1.3 Blaze Collaborators Name Photo Role Years Christian Swanepoel ¬† Blaze (iOS, Android, Testing) 2019 - present 3.2 Roles The following roles can be asignated to one or more people. Role Description Prometheus Only can be assigned to Ethan. Fire Keeper Part of core team. Main admin. Coordinates All Teams and Jasonelle related tasks. Only can be assigned to one person. Forgemaster Part of core team. Focused mainly in one area. Android, iOS, Docs, Community, etc. Blaze Collaborator Sporadical helper. Not part of core team. But can made significant contributions and helping in general. May have to coordinate with a Forgemaster. 3.2.1 Prometheus This role belongs to Ethan. As per wikipedia. In Greek mythology, Prometheus (pronounced [prom…õÀêt ∞√©uÃØs], possibly meaning ‚Äúforethought‚Äù) is a Titan, culture hero, and trickster figure who is credited with the creation of man from clay, and who defies the gods by stealing fire and giving it to humanity, an act that enabled progress and civilisation. Prometheus is known for his intelligence and as a champion of humankind and also seen as the author of the human arts and sciences generally. Same as Prometheus, Ethan gave us the first fire. 3.2.2 Fire Keeper This is a special role. Contains the following responsabilities: Pay for the servers and domains and keep them alive. Coordinate with Forgemasters, Blazes and community members. Define roadmaps and general evolution of the project. Desition making. Promote Jasonelle. Communicate Kindly. This role is similar to the https://en.wikipedia.org/wiki/Benevolent_dictator_for_life but with the consideration that the Fire Keeper could change overtime. It‚Äôs not a ‚Äúfor life‚Äù designation or by any means a ‚Äúdictator‚Äù. But surely is ‚Äúbenevolent‚Äù. Normally is expected that a Fire Keeper stays active for at least 2 years. The Fire Keeper role can only be passed on to a Forgemaster if the current Fire Keeper decides to move on. The Fire Keeper role can be renewed, revoked or renounced. 3.2.2.1 Deadman Clause The Fire Keeper must pass the access keys, admin accounts and other related secrets to at least one trusted Forgemaster of its choosing. In case the Fire Keeper sundenly dissapears or is not active in at least 6 months. The chosen Forgemaster will be considered the new Fire Keeper and have to continue the project and decide it‚Äôs future. This is to mitigate the risk of repeating Ethan suddenly dissapearing. See History. 3.2.3 Forgemaster This role is for people interested in programming, documentation or general support tasks. Contains the following responsabilities: Constantly improve and update code and docs. Participate resolving questions in the community. Take desitions regarding the area of choice. Coordinates with Fire Keeper and other members. Promote Jasonelle. Communicate Kindly. Only one Forgemaster per area can be at the same time. Exceptions could be made if appropiate. Normally is expected that a Forgemaster stays active for at least 6 months. The Forgemaster role can be renewed, revoked or renounced. 3.2.4 Blaze Collaborator A blaze collaborator is a trusted member of the community. Normally someone who can help the core team in small tasks and sporadically test code, detect bugs, answer questions or coordinates various tasks with a Forgemaster. A Blaze is not required to participate actively. But if more than 6 months pass without any significant activity. It would be considered retired. (This status can be changed to active if requested later). The Blaze role can be renewed, revoked or renounced. 3.3 How to Join? Being part of the core team of Jasonelle requires following some simple rules: Weekly Activity: At least some weekly activity related to your role is expected. It‚Äôs not required to have 40 hours weeks. But at least dedicate a few hours a week to the project in order to have meaningful contributions. Find the right balance. Be Kind: Interactions between core members and the community must be as kind as possible. Following the GNU Kind Communication Guidelines. https://www.gnu.org/philosophy/kind-communication.html. 6 months minimum: The least amount of time you must invest is 6 months. If you want to help but don‚Äôt want to go full you can be a Blaze collaborator. Promote Jasonelle: Friendly talk about Jasonelle Technology with people that may have interest in making mobile apps. Maybe in meetups or small talks. Spamming would not be tolerated. Expertise in one or more areas: iOS, Android, JS, Docs, Etc.. If you think this is something you want to do, please contact the current Fire Keeper with your ideas and why you should be a Forgemaster or Blaze. 3.3.1 How to Quit? You can always quit (or be left out) the team. Please contact the Fire Keeper with your request. The Fire Keeper have the rights to fire someone if they: Present continuos non kindly behaviour against the project, team or community members. Participate (directly or indirectly) in unethical or questionable activities that could affect Jasonelle reputation or the community safety. Members of the community or team feels that the role is not being correctly fulfilled. Other considerations. 3.3.2 Are there any profits? This is a community project that does not have direct sources of income to the maintainers. All team members are encouraged to generate revenue by alternative means: Professional Services, Premium Apps, Courses or similar artifacts. Jasonelle project will provide exposure and direct traffic to such activities in order to sustain development. Example: List of Official Apps, Certified Services or Courses. 3.4 Contributions Please create an issue in Jasonelle/Jasonelle before making a pull request in order to talk about how to approach a solution. Also please be aware of the contribution guidelines and agreements of each repository. 3.4.1 Branches Normally each repo contains the following branches. Exceptions may occur if needed. 3.4.1.1 master Stores code that can be used. Is updated once in a while with the code in develop. 3.4.1.2 develop This branch contains bleeding edge code. May break the build. Is merged to master when enough changes (not more than two weeks of work) are made and compiles successfully. Only code in the develop branch can be merged into master. All commits must be merged. No rebasing or squashing. Other branches must be deleted or archived when it‚Äôs purpose is met. uncrustify (or other code style standarization) should be applied before merging into master. 3.4.2 Releases Jasonelle will release a new version every six months (June 9 and November 6) in the repository Jasonelle/Jasonelle. A release will contain the master branch of each relevant repository (Android, iOS, Docs, etc). The code in master must be tagged with the release version. 3.4.3 Version number The version number would be discussed with all the team members before hand. Follows Romantic Versioning. Must be greater than the current version. 3.4.4 Nicknames A nickname can be assigned to a new version. This nickname must be from a Greek Mythology background. https://en.wikipedia.org/wiki/List_of_Greek_mythological_figures. https://en.wikipedia.org/wiki/List_of_Greek_mythological_creatures. The nickname can be chosed by either the core team or from community feedback. 3.4.4.1 June 9 This date marks the last known activity of Ethan. A new release should be made on this week. 3.4.4.2 November 6 This date marks the day Jasonelle Team took the Fire and started this project. A new release should be made on this week. 3.5 Support Jasonelle is made by the collective efforts of different people. Is not funded or sponsored by any company, organization or investor of any kind. If you want to give support to keep development going you can contact members on this list individually. 3.5.1 List of People 3.5.1.1 Ignacio √Ålvarez Role Forgemaster: Android maintainer. Website: https://chauchatraderpro.cl. Services: Jasonelle Support, Android Consulting. Following the same spirit and to help me continue with the project. I leave you my different wallets, in case you want to make a voluntary contribution. Any contribution is welcome, does not matter the amount. Crypto Wallet Chaucha ceoNBCv1JF6GgeAhsFLk6efbRkCX5n8kZn Bitcoin 1CWpA2XnFnfTnbAJN94MpQWyunJgoKYz8K Ethereum 0x9f2688B1a76CC24dA8610E90767c319fb2EA2Af0 Litecoin LVBocBQpqD7FrXiUNrAtrkQtw1JdG6CBQt Bitcoin Cash 14X2cEXpT6BLhFtFhYizCdUgoKtAXede4Z 3.5.1.2 Christian Swanepoel Role Blaze: Android, iOS tester. Website: https://ventum.co.za/. Services: Jasonelle Support, Mobile App Consulting. I have a concrete background and foundation in the creative industry, not only as a designer, but also as a programmer. I am happiest (and most productive) spending time in my own matrix: troubleshooting, coding, writing automation scripts and I have done so on servers all over the globe. I am currently the head of Ventum SA and believe, if I can‚Äôt find the right software solutions for you, we will write it. My journey with Jasonelle started in 2018 stemming from a client brief requiring an in-house corporate application, providing information to their distributed sales team of over 200. As a result, I couldn‚Äôt be happier to have them on Jasonelle, now with an app in both the Android and iOS App stores. As a backend developer, Jasonelle ticked all the boxes, allowing me to continue to develop rad tech, knowing that Jasonelle‚Äôs architecture and close-knit community spirit will make lightweight of any UX requirement. "],
["jasonette.html", "4 Jasonette 4.1 Introduction 4.2 Extensions", " 4 Jasonette Quite a different way to make an app. Make iOS and Android apps with just a single JSON, loaded over HTTP, local file, or anywhere. It has never been trivial to have an idea and turn it into an app quickly. Even for genius programmers. With Jasonette, you don‚Äôt even have to be a programmer. Anyone can make an app. And do it in minutes, not days or weeks. Make an app as fast as it takes to write a blog post. 4.1 Introduction Jasonette abstracts away all low level programming with a JSON based markup. All you need to write is a single JSON. 4.1.1 JSON to Native Components Just like how web browsers turn HTML into a web page, Jasonette turns JSON into iOS and Android native components. This lets you build native apps by writing a simple JSON. Native App over JSON 4.1.1.1 Structure Organize your code in nested JSON objects. Example: { &quot;$jason&quot;: { &quot;head&quot;: {...}, &quot;body&quot;: { &quot;sections&quot;: [{ &quot;items&quot;: [ { &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;...&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;...&quot; }, ... ] }] } } } 4.1.1.2 Layout Construct complex layouts with JSON. Example: Build a card UI with an image, labels, and nested layouts. { &quot;type&quot;: &quot;horizontal&quot;, &quot;components&quot;: [ { &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;file://ethan.jpeg&quot; }, { &quot;type&quot;: &quot;vertical&quot;, &quot;components&quot;: [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Ethan&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot; &quot;www.textethan.com&quot; } ] } ] } 4.1.1.3 Actions Describe actions with JSON. Example: Make a network request and draw the result. { &quot;type&quot;: &quot;$network.request&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;http://api.giphy.com/v1/gifs/search&quot;, &quot;data&quot;: { &quot;q&quot;: &quot;kitten&quot;, &quot;api_key&quot;: &quot;dc6zaTOxFJmzC&quot; } }, &quot;success&quot;: { &quot;type&quot;: &quot;$render&quot; } } 4.1.1.4 Style Style components with JSON. Example: Style a label. { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Hello World&quot;, &quot;style&quot;: { &quot;padding&quot;: &quot;10&quot;, &quot;corner_radius&quot;: &quot;5&quot;, &quot;background&quot;: &quot;rgba(0,0,0,0.4)&quot;, &quot;color&quot;: &quot;#ffffff&quot;, &quot;font&quot;: &quot;HelveticaNeue&quot; } } 4.1.1.5 Native App Over JSON Directly manipulate native APIs simply using JSON. For Android, this means direct access to LinearLayout, RecyclerView, etc. For iOS, this means direct access to UITableView, UIStackView, etc. Want to make changes to your LIVE app? Simply change your JSON content on the server, and watch the app change in front of your eyes, instantly!. 4.1.1.6 Native Components These are some Native Components you can access using just JSON. And much more! Including: Direct access to the device such as camera, audio, geolocation, video, network request, etc. Powerful layout engine that directly manipulates native components such as UITableView, UIStackView, UIView, etc. Describe styling and event handling all with JSON 4.1.1.7 Cross Platform 100% native binary for both Android and iOS. iOS Android 4.1.2 Free &amp; Battle Tested Jasonette was extracted from several production apps on the App Store, so you know it works. Below are some actual production apps built with Jasonette. Kitty Catch All 4.1.2.1 100% FREE Everything is free for you to use. There is no small print that says ‚Äúpay $$$ if you want to publish your app‚Äù. It‚Äôs all yours. 4.1.2.2 100% OPEN SOURCE Jasonette is licensed under MIT license. Take the code, build and publish your own apps, and do whatever you want with it! 4.1.2.3 100% PORTABLE There is no magical backend server you need to learn to use, pay for, or install to use Jasonette. ALL YOU NEED IS JSON. If you have a web server, you ALREADY have a Jasonette server. 4.1.2.4 100% EXTENSIBLE Jasonette is essentially just an engine that maps JSON expression to native components and actions. It doesn‚Äôt force you to drop everything and adopt the technology exclusively. You can extend it or even integrate it with your existing native code seamlessly. 4.2 Extensions Jasonette is easily extendable. You can add your own native code actions, components or services and call them using JSON. More Examples https://github.com/jasonelle/docs/tree/develop/examples/jasonette/extensions 4.2.1 The jr.json This file contains the configuration that Jasonette needs to detect the extension. Example: https://github.com/jasonelle/docs/tree/develop/examples/jasonette/extensions/ios/vibration-action { &quot;version&quot;: &quot;0.1.0&quot;, &quot;name&quot;: &quot;vibration&quot;, &quot;classname&quot;: &quot;JasonVibrationAction&quot;, &quot;platform&quot;: &quot;ios&quot;, &quot;language&quot; : &quot;objective-c&quot;, &quot;author&quot; : &quot;Jasonelle&quot;, &quot;href&quot; : &quot;https://jasonelle.com&quot;, &quot;license&quot; : &quot;MIT&quot;, &quot;description&quot;: &quot;$vibration.activate makes the device vibrate.&quot; } At the minimum it must have two properties: name: is the one who defines how Jasonette will identify this component. In the example is vibration. The json object will be $vibration. classname: tells which file will be used for this action. This is used in Jasonette to load the class. It must follow the pattern Jason&lt;Name&gt;Action for actions and Jason&lt;Name&gt;Component for components. It‚Äôs a good practice to include a test.json with a sample app that uses your action/component. name and classname could be different for the same component. is important that they not conflict with other actions or components. Your jr.json file must be a JSON file which contains the following attributes: version: Follows semantic versioning. Must upgrade everytime you make a change to your repo and wish to update the registry with the latest version. name: This is the name that will be used in the JSON. For example if you set this console and your main class contains methods named debug or log, you can call &quot;type&quot;: &quot;$console.debug&quot; or &quot;type&quot;: &quot;$console.log&quot; actions in your JSON markup. description: This is the description that will show up on the registry list when you open the extension manager classname: This is the main class name that will be linked with the name attribute above. So if you set the classname attribute as JasonConsoleAction, Jasonette will look for JasonConsoleAction class every time it runs into the JSON markup specified by the name attribute above. platform: Specify your platform. Currently can only be &quot;ios&quot; or &quot;android&quot; dependencies: If you‚Äôre using 3rd party libraries via Cocoapods or gradle, you need to add the lines you would normally use in a Podfile (for ios) or a build.gradle file (for android). For example: &quot;dependencies&quot;: [ &quot;compile 'com.segment.analytics.android:analytics:4.+'&quot; ], or &quot;dependencies&quot;: [&quot;pod 'Analytics', '~&gt; 3.0'&quot;] 4.2.2 iOS The following information is related to creating extensions in iOS. 4.2.2.1 Creating Extensions You can create extensions with native Objective-C or Swift. If you are using Swift for an Extension use the @objc() annotation. @objc(MySwiftClass) class MySwiftClass { // ... } Extensions must be childs of the parent class JasonAction or JasonComponent. 4.2.2.1.1 Jason The Jason is the main singleton for executing actions and other operations. 4.2.2.1.1.1 call Use Jason.client.call to trigger an action related to an element. The element should decide when to call this action. [[Jason client] call:json[@&quot;action&quot;]]; You can also call using params [[Jason client] call:json[@&quot;action&quot;] with:@{ @&quot;$jason&quot;: payload }]; Or type your json directly [[Jason client] call:@{ @&quot;type&quot;: @&quot;$href&quot;, @&quot;options&quot;: userInfo[@&quot;href&quot;] }]; 4.2.2.1.1.2 go Use Jason.client.go to load a view inside a file:// or http[s]:// url. [[Jason client] go:userInfo[@&quot;href&quot;]]; 4.2.2.1.1.3 getVC Obtain the current JasonViewController object. [[[Jason client] getVC]; 4.2.2.1.2 JasonAction Defines actions that could be performed using the action property. { &quot;action&quot; : { &quot;type&quot;: &quot;$myaction&quot; } } Interface: The action must be child of JasonAction and follow the naming convention. #import &quot;JasonAction.h&quot; @interface JasonMyCustomAction : JasonAction @end Implementation: Each method will be available as $myaction.mymethod in this case would be $myaction.get - (void) get { NSLog(@&quot;Hello&quot;); } 4.2.2.1.3 Methods All the input and output must be using the Jason class using the client singleton. Example [[Jason client] success:@{ @&quot;coord&quot;: coord }]; 4.2.2.1.3.1 options The dictionary self.options contains all the params provided in the json file. NSString * name = self.options[@&quot;name&quot;]; 4.2.2.1.3.2 success Call Jason.client.success method to return a value. And execute the success callback in the json. The params provided would be available inside the $jason property. [[Jason client] success:@{}]; 4.2.2.1.3.3 error Call Jason.client.error method to execute the error callback in the json. [[Jason client] error]; 4.2.2.1.4 Example: JasonVibrationAction JasonVibrationAction.h #import &quot;JasonAction.h&quot; @interface JasonVibrationAction : JasonAction @end JasonVibrationAction.m #import &quot;JasonVibrationAction.h&quot; #import &quot;JasonOptionHelper.h&quot; #import &lt;AVFoundation/AVFoundation.h&gt; #define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending) // AudioServicesPlaySystemSound (1352) works for iPhones regardless of silent switch position int const kForceVibrationId = 1352; @implementation JasonVibrationAction // use this as $vibration.activate - (void) activate { BOOL forceVibration = [self.options[@&quot;force&quot;] boolValue]; int vibrationId = kSystemSoundID_Vibrate; if (forceVibration &amp;&amp; [[UIDevice currentDevice].model isEqualToString:@&quot;iPhone&quot;]) { vibrationId = kForceVibrationId; } if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;9.0&quot;)) { AudioServicesPlayAlertSoundWithCompletion(vibrationId, nil); } else { AudioServicesPlayAlertSound(vibrationId); } [[Jason client] success]; } @end 4.2.2.1.5 JasonComponent A component is an UIView that could be rendered by the JasonComponentFactory. { &quot;type&quot; : &quot;mycomponent&quot; } Interface: The component must be child of JasonComponent and follow the naming convention. #import &quot;JasonComponent.h&quot; @interface JasonMyCustomComponent : JasonComponent @end Implementation: The component must implement the following method + (UIView *) build:(UIView *)component withJSON:(NSDictionary *)json withOptions:(NSDictionary *)options; 4.2.2.1.5.1 Properties component: Should be returned with all the styles and options applied. json: Contains the properties name, action and style. options: Contains the params. component can‚Äôt be nil Component param can‚Äôt be nil. always check and build the component if needed. if (!component) { component = [[UIView alloc] init]; } 4.2.2.1.6 Methods Most information is stored in the params of the implementation. Some of the following methods can become handy. 4.2.2.1.6.1 stylize Use the stylize to apply common styles configuration to the component. [self stylize:json component:component]; Call this method before applying your custom styles. 4.2.2.1.6.2 updateForm Use the updateForm method to return values to the json. Use a NSDictionary with the component name to the set values. [self updateForm:@{ json[@&quot;name&quot;]: newValue }]; 4.2.2.1.6.3 Target Actions Is recommended to use the Target-Action to listen to component events. https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html // Remove then add to ensure uniqueness [component removeTarget:self action:@selector(myselector:) forControlEvents:UIControlEventValueChanged]; [component addTarget:self action:@selector(myselector:) forControlEvents:UIControlEventValueChanged]; Create custom handlers and use Jason.client.call to trigger the action associated with the component. 4.2.2.1.7 Example: JasonSpaceComponent JasonSpaceComponent.h #import &quot;JasonComponent.h&quot; #import &quot;JasonHelper.h&quot; @interface JasonSpaceComponent : JasonComponent @end JasonSpaceComponent.m #import &quot;JasonSpaceComponent.h&quot; @implementation JasonSpaceComponent + (UIView *) build:(UIView *)component withJSON:(NSDictionary *)json withOptions:(NSDictionary *)options { if (!component) { component = [[UIView alloc] init]; } if ([options[@&quot;parent&quot;] isEqualToString:@&quot;vertical&quot;]) { [component setContentHuggingPriority:1 forAxis:UILayoutConstraintAxisVertical]; } else if ([options[@&quot;parent&quot;] isEqualToString:@&quot;horizontal&quot;]) { [component setContentHuggingPriority:1 forAxis:UILayoutConstraintAxisHorizontal]; } component.translatesAutoresizingMaskIntoConstraints = false; // Apply Common Style [self stylize:json component:component]; return component; } @end 4.2.2.1.8 JasonService A service is a special extension that will not be deallocated when the view changes. They are similar to daemons that runs in background processes. Some services are: $agent, $websocket, $vision and $push. They do not need to extend a base class. But they must implement the initialize: method called in the AppDelegate. And follow the naming convention Jason&lt;Name&gt;Service. - (void) initialize:(NSDictionary *)launchOptions; 4.2.2.1.8.1 Accessing a Service For accessing a service object use the Jason.client.services property. This could be used inside an action or component that interacts with the service. JasonPushService * service = [Jason client].services[@&quot;JasonPushService&quot;]; 4.2.2.1.8.2 Example: JasonVisionService and JasonVisionAction JasonVisionService.h #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt; #import &quot;Jason.h&quot; #import &quot;JasonMemory.h&quot; @interface JasonVisionService : NSObject &lt;AVCaptureMetadataOutputObjectsDelegate&gt; @property (nonatomic, assign) BOOL is_open; @end JasonVisionService.m #import &quot;JasonVisionService.h&quot; #import &quot;JasonLogger.h&quot; @implementation JasonVisionService - (void) initialize:(NSDictionary *)launchOptions { self.is_open = NO; DTLogDebug(@&quot;initialize&quot;); } - (void) captureOutput:(AVCaptureOutput *)output didOutputMetadataObjects:(NSArray&lt;__kindof AVMetadataObject *&gt; *)metadataObjects fromConnection:(AVCaptureConnection *)connection { if (!self.is_open) { return; } NSDictionary * events = [[[Jason client] getVC] valueForKey:@&quot;events&quot;]; if (![JasonMemory client].executing) { for (AVMetadataObject * metadata in metadataObjects) { AVMetadataMachineReadableCodeObject * transformed = (AVMetadataMachineReadableCodeObject *) metadata; self.is_open = NO; [[Jason client] call:events[@&quot;$vision.onscan&quot;] with:@{ @&quot;$jason&quot;: @{ @&quot;content&quot;: transformed.stringValue, @&quot;type&quot;: transformed.type } }]; return; } } } @end JasonVisionAction.m #import &quot;JasonAction.h&quot; #import &quot;JasonVisionService.h&quot; #import &quot;Jason.h&quot; @interface JasonVisionAction : JasonAction @end JasonVisionAction.m #import &quot;JasonVisionAction.h&quot; @implementation JasonVisionAction // $vision.scan - (void) scan { JasonVisionService * service = [Jason client].services[@&quot;JasonVisionService&quot;]; service.is_open = YES; [[Jason client] success]; } @end "],
["ja-js-selector-transformer.html", "5 Ja.js - Selector Transformer 5.1 Repository 5.2 Playground 5.3 Introduction 5.4 Select 5.5 Transform 5.6 Sample Projects", " 5 Ja.js - Selector Transformer Ja.js (previously named st.js) is a library that enables implementing practically any programming concept in a declarative manner, using JSON. This is because ja.js is a low level building block for creating a Turing Complete JSON markup language. ja.js is the core JSON parser that powers Jasonette, so you can build native iOS/Android apps by writing nothing but a JSON markup. Ja.js But Jasonette is just one implementation. Want to build your own turing complete JSON markup language? 5.1 Repository https://github.com/jasonelle/ja.js 5.2 Playground Parse JSON anywhere, both frontend and backend, as easy as using JSON.stringify or JSON.parse. https://jasonelle.com/docs/playground-ja/ Source Code: https://github.com/jasonelle/docs/tree/develop/playground-ja. 5.3 Introduction ja.js is a library that adds a couple of powerful methods to JavaScript‚Äôs native JSON. So you can simply use it with the syntax ST.select(...).transform(...). The library is just a single file, made up of stateless functions, with NO dependency. Which makes it effortless to embed anywhere without hassle. (Currently used in various environments including iOS, Android, node.js, browser, etc.). What Can I Use It For? JSON powers almost everything in the world. Being able to bend any JSON to your will means you can do all kinds of magical things. Ja.js consist mainly of two operations: Select: Query any JSON tree to select exactly the subtree you are looking for. Transform: Transform any JSON object to another by parsing with a template, also written in JSON You can also mix and match Select AND Transform to perform partial transform, modularize JSON objects, etc. 5.3.1 Select Select a JSON object or its subtree that matches your filter function criteria. Step 1. Take any JSON object var data = { &quot;links&quot;: [ { &quot;remote_url&quot;: &quot;http://localhost&quot; }, { &quot;file_url&quot;: &quot;file://documents&quot; }, { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; } ], &quot;preview&quot;: &quot;https://image&quot;, &quot;metadata&quot;: &quot;This is a link collection&quot; } Step 2. Find all key/value pairs that match a selector function var sel = ST.select(data, function(key, val) { return /https?:/.test(val); }) Step 3. Get the result var keys = sel.keys(); // [ // &quot;remote_url&quot;, // &quot;remote_url&quot;, // &quot;preview&quot; // ] var values = sel.values(); // [ // &quot;http://localhost&quot;, // &quot;https://blahblah.com&quot;, // &quot;https://image&quot; // ] var paths = sel.paths(); // [ // &quot;[\\&quot;links\\&quot;]&quot;, // &quot;[\\&quot;links\\&quot;]&quot;, // &quot;&quot; // ] 5.3.2 Transform Transform any JSON with a declarative template, also in JSON. Step 1. Take any JSON object var data = { &quot;title&quot;: &quot;List of websites&quot;, &quot;description&quot;: &quot;This is a list of popular websites&quot; &quot;data&quot;: { &quot;sites&quot;: [{ &quot;name&quot;: &quot;Google&quot;, &quot;url&quot;: &quot;https://google.com&quot; }, { &quot;name&quot;: &quot;Facebook&quot;, &quot;url&quot;: &quot;https://facebook.com&quot; }, { &quot;name&quot;: &quot;Twitter&quot;, &quot;url&quot;: &quot;https://twitter.com&quot; }, { &quot;name&quot;: &quot;Github&quot;, &quot;url&quot;: &quot;https://github.com&quot; }] } } Step 2. Select and transform with a template JSON object var sel = ST.select(data, function(key, val){ return key === &#39;sites&#39;; }) .transformWith({ &quot;items&quot;: { &quot;{{#each sites}}&quot;: { &quot;tag&quot;: &quot;&lt;a href=&#39;{{url}}&#39;&gt;{{name}}&lt;/a&gt;&quot; } } }) Step 3. Get the result var keys = sel.keys(); // [ // &quot;tag&quot;, // &quot;tag&quot;, // &quot;tag&quot;, // &quot;tag&quot; // ] var values = sel.values(); // [ // &quot;&lt;a href=&#39;https://google.com&#39;&gt;Google&lt;/a&gt;&quot;, // &quot;&lt;a href=&#39;https://facebook.com&#39;&gt;Facebook&lt;/a&gt;&quot;, // &quot;&lt;a href=&#39;https://twitter.com&#39;&gt;Twitter&lt;/a&gt;&quot;, // &quot;&lt;a href=&#39;https://github.com&#39;&gt;Github&lt;/a&gt;&quot; // ] var objects = sel.objects(); // [ // { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://google.com&#39;&gt;Google&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://facebook.com&#39;&gt;Facebook&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://twitter.com&#39;&gt;Twitter&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://github.com&#39;&gt;Github&lt;/a&gt;&quot; // } // ] var root = sel.root(); // { // &quot;items&quot;: [{ // &quot;tag&quot;: &quot;&lt;a href=&#39;https://google.com&#39;&gt;Google&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://facebook.com&#39;&gt;Facebook&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://twitter.com&#39;&gt;Twitter&lt;/a&gt;&quot; // }, { // &quot;tag&quot;: &quot;&lt;a href=&#39;https://github.com&#39;&gt;Github&lt;/a&gt;&quot; // }] // } 5.3.3 Usage 5.3.3.1 In a browser &lt;script src=&quot;ja.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var parsed = ST.select({ &quot;items&quot;: [1,2,3,4] }) .transformWith({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{this}}&quot; } }) .root(); &lt;/script&gt; 5.3.3.2 In node.js Install through npm: $ npm install stjs Use const ST = require(&#39;st&#39;); const parsed = ST.select({ &quot;items&quot;: [1,2,3,4] }) .transformWith({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{this}}&quot; } }) .root(); 5.4 Select Select a JSON object or its subtree that matches your filter function. 5.4.1 Syntax ST.select(data, selectorFunction); 5.4.1.1 Parameters data : Any JavaScript object selectorFunction : selectorFunction is a predicate, to test each key/value pairs of the entire JSON tree. Return true to keep the element, false otherwise, taking two arguments: key : the ‚Äúkey‚Äù of the current key/value pair being tested. value : the ‚Äúvalue‚Äù of the current key/value pair being tested. 5.4.1.2 Return Value Returns a selection object which can be queried to retrieve the final result, using the following API: values() : Array of values for all the key/value pair matches. keys() : Array of keys for all the key/value pair matches. paths() : Array of paths leading to all the key/value pair matches. objects() : Array of full objects in which the key/value match was found. root() : Retrieve the root node. Useful when used along with transform. 5.4.2 Example You can select any JSON tree to find only the subtrees that satisfy your needs. Take any data var data = { links: [ { &quot;remote_url&quot;: &quot;http://localhost&quot; }, { &quot;file_url&quot;: &quot;file://documents&quot; }, { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; } ], preview: &quot;https://image&quot;, metadata: &quot;This is a link collection&quot; }; Select subtree var selection = ST.select(data, function(key, val) { return /https?:/.test(val); }) Query the selection object var selected_values = selection.values(); // [ // &quot;http://localhost&quot;, // &quot;https://blahblah.com&quot;, // &quot;https://image&quot; // ] var selected_keys = selection.keys(); // [ // &quot;remote_url&quot;, // &quot;remote_url&quot;, // &quot;preview&quot; // ] var selected_objects = selection.objects(); // [ // { &quot;remote_url&quot;: &quot;http://localhost&quot; }, // { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; }, // { // &quot;links&quot;: [ // { &quot;remote_url&quot;: &quot;http://localhost&quot; }, // { &quot;file_url&quot;: &quot;file://documents&quot; }, // { &quot;remote_url&quot;: &quot;https://blahblah.com&quot; } // ], // &quot;preview&quot;: &quot;https://image&quot;, // &quot;metadata&quot;: &quot;This is a link collection&quot; // } // ] // // var selected_paths = selection.paths(); // [ // &quot;[\\&quot;links\\&quot;][0]&quot;, // &quot;[\\&quot;links\\&quot;][2]&quot;, // &quot;&quot; // ] 5.5 Transform Transform any JSON with a declarative template, also in JSON. 5.5.1 Syntax There are 2 ways of transforming an object: 5.5.1.1 transform() Select a template or its subtree, and transform data with the selected template. ST.select(TEMPLATE).transform(DATA) ST.select({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } }) .transform({ items: [ { id: 1, name: &quot;Ja&quot; }, { id: 2, name: &quot;Ka&quot; }, { id: 3, name: &quot;La&quot; } ] }) .root(); 5.5.1.2 transformWith() Select a data object or its subtree and transform with a template. ST.select(DATA).transformWith(TEMPLATE) ST.select({ items: [ { id: 1, name: &quot;Ja&quot; }, { id: 2, name: &quot;Ka&quot; }, { id: 3, name: &quot;La&quot; } ] }) .transformWith({ &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } }) .root(); 5.5.2 Basic Use {{ }} notation to fill out a template with data to generate a new JSON. Template and Data var template = { &quot;menu&quot;: { &quot;flavor&quot;: &quot;{{flavor}}&quot;, &quot;richness&quot;: &quot;{{richness}}&quot;, &quot;garlic amount&quot;: &quot;{{garlic_amount}}&quot;, &quot;green onion?&quot;: &quot;{{green_onion}}&quot;, &quot;sliced pork?&quot;: &quot;{{pork_amount}}&quot;, &quot;secret sauce&quot;: &quot;{{sauce_amount}}&quot;, &quot;noodle&#39;s texture&quot;: &quot;{{texture}}&quot; } } var data = { &quot;flavor&quot;: &quot;strong&quot;, &quot;richness&quot;: &quot;ultra rich&quot;, &quot;garlic_amount&quot;: &quot;1 clove&quot;, &quot;green_onion&quot;: &quot;thin green onion&quot;, &quot;pork_amount&quot;: &quot;with&quot;, &quot;sauce_amount&quot;: &quot;double&quot;, &quot;texture&quot;: &quot;extra firm&quot; } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;menu&quot;: { &quot;flavor&quot;: &quot;strong&quot;, &quot;richness&quot;: &quot;ultra rich&quot;, &quot;garlic amount&quot;: &quot;1 clove&quot;, &quot;green onion?&quot;: &quot;thin green onion&quot;, &quot;sliced pork?&quot;: &quot;with&quot;, &quot;secret sauce&quot;: &quot;double&quot;, &quot;noodle&#39;s texture&quot;: &quot;extra firm&quot; } } 5.5.3 Loop Use #each to iterate through items. Template and Data var template = { &quot;orders&quot;: { &quot;{{#each customers}}&quot;: { &quot;order&quot;: &quot;One {{menu}} for {{name}}!&quot; } } } var data = { &quot;customers&quot;: [{ &quot;name&quot;: &quot;Hatter&quot;, &quot;menu&quot;: &quot;miso ramen&quot; }, { &quot;name&quot;: &quot;March Hare&quot;, &quot;menu&quot;: &quot;tonkotsu ramen&quot; }, { &quot;name&quot;: &quot;Dormouse&quot;, &quot;menu&quot;: &quot;miso ramen&quot; }, { &quot;name&quot;: &quot;Alice&quot;, &quot;menu&quot;: &quot;cup noodles&quot; }] } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;orders&quot;: [{ &quot;order&quot;: &quot;One miso ramen for Hatter!&quot; }, { &quot;order&quot;: &quot;One tonkotsu ramen for March Hare!&quot; }, { &quot;order&quot;: &quot;One miso ramen for Dormouse!&quot; }, { &quot;order&quot;: &quot;One cup noodles for Alice!&quot; }] } 5.5.4 Conditionals Use #if / #elseif / #else to selectively fill out a template. Template and Data var template = { &quot;response&quot;: [{ &quot;{{#if spicy &lt; 7}}&quot;: { &quot;message&quot;: &quot;Coming right up!&quot; } }, { &quot;{{#elseif spicy &lt; 9}}&quot;: { &quot;message&quot;: &quot;Are you sure? It is very spicy&quot; } }, { &quot;{{#else}}&quot;: { &quot;message&quot;: &quot;Please sign here where it says you&#39;re responsible for this decision&quot; } }] } var data = { &quot;spicy&quot;: 8 } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;response&quot;: { &quot;message&quot;: &quot;Are you sure? It is very spicy&quot; } } 5.5.5 Existencial Operator You can use the existential operator #? to exclude an attribute altogether if the template evaluates to a falsy value. Template and Data var data = { notifications: { home: 1, invite: 2 } }; var template = { tabs: [{ text: &quot;home&quot;, badge: &quot;{{#? notifications.home}}&quot; }, { text: &quot;message&quot;, badge: &quot;{{#? notification.message}}&quot; }, { text: &quot;invite&quot;, badge: &quot;{{#? notification.invite}}&quot; }] } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { tabs: [{ text: &quot;home&quot;, badge: 1 }, { text: &quot;message&quot; }, { text: &quot;invite&quot;, badge: 2 }] } 5.5.6 Concat You can concatenate multiple items and arrays into a single array using the #concat operator. Template and Data var data = { numbers: [1,2,3] }; var template = { &quot;items&quot;: { &quot;{{#concat}}&quot;: [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: {{numbers.length}}&quot; }, { &quot;{{#each numbers}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{this}}&quot; } } ] } }; Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;items&quot;: [{ &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: 3&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: 1 }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: 2 }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: 3 }] } 5.5.7 Merge You can merge multiple objects into a single object using the #merge operator. If there are any overlapping attributes, the ones that come later will override the previously set attribute. Template and Data var data = { numbers: [1,2,3], align: &quot;right&quot;, size: &quot;14&quot; }; var template = { &quot;{{#merge}}&quot;: [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: {{numbers.length}}&quot; }, { &quot;style&quot;: { &quot;align&quot;: &quot;{{align}}&quot;, &quot;size&quot;: &quot;{{size}}&quot; }, &quot;action&quot;: { &quot;type&quot;: &quot;$render&quot; } } ] }; Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Length: 3&quot;, &quot;style&quot;: { &quot;align&quot;: &quot;right&quot;, &quot;size&quot;: &quot;14&quot; }, &quot;action&quot;: { &quot;type&quot;: &quot;$render&quot; } } 5.5.8 Inline JavaScript You can use ANY native javascript expression inside the template. Template and Data var template = { &quot;ranking&quot;: { &quot;{{#each players.sort(function(p1, p2) { return p2.quantity - p1.quantity; }) }}&quot;: &quot;{{name}} ate {{quantity}}&quot; }, &quot;winner&quot;: &quot;{{players.sort(function(p1, p2) { return p2.quantity - p1.quantity; })[0].name }}&quot; }; var data = { &quot;players&quot;: [{ &quot;name&quot;: &quot;Alice&quot;, &quot;quantity&quot;: 102 }, { &quot;name&quot;: &quot;Mad Hatter&quot;, &quot;quantity&quot;: 108 }, { &quot;name&quot;: &quot;Red Queen&quot;, &quot;quantity&quot;: 100 }] }; Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;ranking&quot;: [ &quot;Mad Hatter ate 108&quot;, &quot;Alice ate 102&quot;, &quot;Red Queen ate 100&quot; ], &quot;winner&quot;: &quot;Mad Hatter&quot; } 5.5.9 $root Sometimes you need to refer to the root data object while iterating through an #each loop. In this case you can use a special keyword named $root. Template and Data var template = { &quot;{{#each posts}}&quot;: [ &quot;{{content}}&quot;, &quot;{{$root.users[user_id]}}&quot; ] } var data = { users: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;], posts: [{ content: &quot;Show me the money&quot;, user_id: 1 }, { content: &quot;hello world&quot;, user_id: 0 }, { content: &quot;what is the meaning of life?&quot;, user_id: 2 }] } Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result [ [&quot;Show me the money&quot;, &quot;Bob&quot;], [&quot;hello world&quot;, &quot;Alice&quot;], [&quot;what is the meaning of life?&quot;, &quot;Carol&quot;] ] 5.5.10 $index You can use a special variable named $index within #each loops. Template and Data const template = { &quot;rows&quot;: { &quot;{{#each items}}&quot;: { &quot;row_number&quot;: &quot;{{$index}}&quot;, &quot;columns&quot;: { &quot;{{#each this}}&quot;: { &quot;content&quot;: &quot;{{this}}&quot;, &quot;column_number&quot;: &quot;{{$index}}&quot; } } } } }; const data = { &quot;items&quot;: [ [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;], [1,2,3,4,5] ] }; const result = ST.select(template) .transform(data) .root() // or // const result = ST.transform(template, data) Select and Transform ST.select(template) .transform(data) .root(); // or // ST.transform(template, data) Result { &quot;rows&quot;: [ { &quot;row_number&quot;: 0, &quot;columns&quot;: [ { &quot;content&quot;: &quot;a&quot;, &quot;column_number&quot;: 0 }, { &quot;content&quot;: &quot;b&quot;, &quot;column_number&quot;: 1 }, { &quot;content&quot;: &quot;c&quot;, &quot;column_number&quot;: 2 }, { &quot;content&quot;: &quot;d&quot;, &quot;column_number&quot;: 3 }, { &quot;content&quot;: &quot;e&quot;, &quot;column_number&quot;: 4 } ] }, { &quot;row_number&quot;: 1, &quot;columns&quot;: [ { &quot;content&quot;: 1, &quot;column_number&quot;: 0 }, { &quot;content&quot;: 2, &quot;column_number&quot;: 1 }, { &quot;content&quot;: 3, &quot;column_number&quot;: 2 }, { &quot;content&quot;: 4, &quot;column_number&quot;: 3 }, { &quot;content&quot;: 5, &quot;column_number&quot;: 4 } ] } ] } 5.5.11 Local Variables You can use #let API to declare local variables. The #let API takes an array as a paremeter, which has two elements: The first parameter: the {{#let}} statement which assigns any value to a variable. The second parameter: the actual expression that will be evaluated. Here‚Äôs an example: Template and Data const data = { families: [{ location: &quot;Wonderland&quot;, members: [{ name: &quot;Alice&quot; }, { name: &quot;Bob&quot; }] }, { location: &quot;Springfield&quot;, members: [{ name: &quot;Bart&quot; }, { name: &quot;Marge&quot; }, { name: &quot;Lisa&quot; }, { name: &quot;Homer&quot; }, { name: &quot;Maggie&quot; }] }] } const template = { &quot;rows&quot;: { &quot;{{#each families}}&quot;: { &quot;{{#let}}&quot;: [{ &quot;family_location&quot;: &quot;{{location}}&quot; }, { &quot;{{#each members}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}} in {{family_location}}&quot; } }] } } } Select and Transform const result = ST.select(template) .transform(data) .root() // or // const result = ST.transform(template, data) Result { &quot;rows&quot;: [ [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Alice in Wonderland&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Bob in Wonderland&quot; } ], [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Bart in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Marge in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Lisa in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Homer in Springfield&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Maggie in Springfield&quot; } ] ] } The local variable feature is important when you are using nested loops. You could use the $root variable to reach out of the current loop context, but this has limitations, because you can always only reach out to the root level. By using the #let API, you can define a variable at any level of a loop and have it accessible from anywhere further down the loop WITHOUT using the $root variable. 5.5.12 Example 1 - Use only a subtree of a template Sometimes you don‚Äôt want to use the entire template to parse data. In this case you can select a subtree of a template and use that to parse data. var template = { body: { sections: [{ items: { &quot;{{#each items}}&quot;: { type: &quot;{{type}}&quot;, url: &quot;{{url}}&quot; } } }] } }; var finalTemplate = ST.select(template, function(key, val) { return key === &#39;type&#39;; }) .transform({ type: &quot;image&quot; }).root(); /* finalTemplate = { body: { sections: [{ items: { &quot;{{#each items}}&quot;: { type: &quot;image&quot;, url: &quot;{{url}}&quot; } } }] } } */ 5.5.13 Example 2 - Filter Data + Transform with template Sometimes you have a large set of data but only want to transform a portion of it. In this case you can select a subtree of the data object and parse using a template. var data = { &quot;item&quot;: { &quot;url&quot;: &quot;http://localhost&quot;, &quot;text&quot;: &quot;localhost&quot; }, &quot;items&quot;: [ { &quot;url&quot;: &quot;file://documents&quot;, &quot;text&quot;: &quot;documents&quot; }, { &quot;url&quot;: &quot;https://blahblah.com&quot;, &quot;text&quot;: &quot;blah&quot; } ], &quot;nestedItems&quot;: { &quot;childItems&quot;: [{ &quot;url&quot;: &quot;http://hahaha.com&quot;, &quot;text&quot;: &quot;haha&quot; }, { &quot;url&quot;: &quot;https://hohoho.com&quot;, &quot;text&quot;: &quot;hoho&quot; }] } }; var selection = ST.select(data, function(key, val) { return key === &#39;url&#39;; }); var urls = selection.values(); /** * urls = [ * &quot;http://localhost&quot;, * &quot;file://documents&quot;, * &quot;https://blahblah.com&quot;, * &quot;http://hahaha.com&quot;, * &quot;https://hohoho.com&quot; * ] */ var transformed = selection.transformWith({ &quot;tag&quot;: &quot;&lt;a href=&#39;{{url}}&#39;&gt;{{text}}&lt;/a&gt;&quot; }) var objects = transformed.objects() /** * objects = [ * { &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } * ] */ var values = transformed.values() /** * values = [ * &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;https://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot;, * &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; * ] */ var keys = transformed.keys() /** * keys = [&quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;] */ var root = transformed.root() /** * root = { * &quot;item&quot;: { * &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; * }, * &quot;items&quot;: [ * { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; }, * ], * &quot;nestedItems&quot;: { * &quot;childItems&quot;: [ * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, * { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } * ] * } * }; */ var transformed = ST.select({ &quot;{{#each items}}&quot;: { tag: &quot;&lt;a href=&#39;{{url}}&#39;&gt;{{text}}&lt;/a&gt;&quot; } }).transform({ items: urls }); var root = transformed.root(); /* root = { &quot;item&quot;: { &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; }, &quot;items&quot;: [ { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; } ], &quot;nestedItems&quot;: { &quot;childItems&quot;: { &quot;tag&quot;: &quot;&lt;a href=&#39;http://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } } */ var keys = transformed.keys(); /* keys = [&quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;tag&quot;]; */ var values = transformed.values(); /* values = [ &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;http://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot;, &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; ] */ var objects = transformed.objects(); /* objects = [ { &quot;tag&quot;: &quot;&lt;a href=&#39;http://localhost&#39;&gt;localhost&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;file://documents&#39;&gt;documents&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;https://blahblah.com&#39;&gt;blah&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;http://hahaha.com&#39;&gt;haha&lt;/a&gt;&quot; }, { &quot;tag&quot;: &quot;&lt;a href=&#39;https://hohoho.com&#39;&gt;hoho&lt;/a&gt;&quot; } ] */ var paths = transformed.paths(); 5.5.14 Example 3 - Nesting Templates Sometimes you may want to reuse a template by nesting inside another template. In this case you just need to select a subtree of the parent template and plug in a child template. var data = { &quot;item&quot;: { &quot;url&quot;: &quot;http://localhost&quot; }, &quot;items&quot;: [ { &quot;url&quot;: &quot;file://documents&quot; }, { &quot;url&quot;: &quot;https://blahblah.com&quot; } ], &quot;nestedItems&quot;: { &quot;childItems&quot;: [{ &quot;url&quot;: &quot;http://hahaha.com&quot;, &quot;text&quot;: &quot;haha&quot; }, { &quot;url&quot;: &quot;https://hohoho.com&quot;, &quot;text&quot;: &quot;hoho&quot; }] } }; var template = { &quot;items&quot;: { &quot;{{#each items}}&quot;: &quot;{{partial}}&quot; } } var partial = { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } var selected = ST.select(template, function(key, val) { return val === &#39;{{partial}}&#39;; }) var finalTemplate = selected.transform({ &quot;partial&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } }).root(); /* finalTemplate = { &quot;items&quot;: { &quot;{{#each items}}&quot;: { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;{{name}}&quot; } } } */ 5.6 Sample Projects 5.6.1 Declarative JSON API Template Build JSON using a simple, human-readable, and declarative template instead of manually coding it. See the example code at: https://github.com/jasonelle/st.js-api.template Old way: Manually construct object // app.js app.get(&#39;/&#39;, function (req, res) { var response = {} response[&quot;current_user&quot;] = { username: &quot;@&quot; + req.user.username, firstname: req.user.name.split(&#39; &#39;)[0], lastname: req.user.name.split(&#39; &#39;)[1] } var transformed_posts = db.posts.map(function(post){ return { slug: post.slug permalink: &quot;https://blahblahblah.blahblah/&quot; + post.slug, post_title: post.title, post_content: post.content } }) response[&quot;posts&quot;] = transformed_posts res.json(response) }) New way: Declarative approach with ja.js // app.js app.get(&#39;/&#39;, function (req, res) { res.json(ST.select(require(&#39;./template.json&#39;)) .transform({user: req.user, posts: db.posts}) .root()) }) // template.json { &quot;current_user&quot;: { &quot;username&quot;: &quot;@{{user.username}}&quot;, &quot;firstname&quot;: &quot;{{user.name.split(&#39; &#39;)[0]}}&quot;, &quot;lastname&quot;: &quot;{{user.name.split(&#39; &#39;)[1]}}&quot; }, &quot;posts&quot;: { &quot;{{#each posts}}&quot;: { &quot;slug&quot;: &quot;{{slug}}&quot;, &quot;permalink&quot;: &quot;https://blahblahblah.blahblah/{{slug}}&quot;, &quot;post_title&quot;: &quot;{{title}}&quot;, &quot;post_content&quot;: &quot;{{content}}&quot; } } } 5.6.2 JSON as a JSON Query Language Make complex API queries purely written in JSON. Since templates in ST are written in JSON, you can pass them around anywhere just like any other data object. Notice we‚Äôre not creating some new query language, it‚Äôs just JSON. No convoluted infrastructure to set up! See the example code at: https://github.com/jasonelle/st.js-jsonql 5.6.3 App as data Templates are normally used for views But the cool thing about JSON is it can be used to declaratively represent ANYTHING from Model to View to Controller. What if we set executable functions as leaf nodes of an object, select &amp; transform it, and then auto-trigger the resolved function? We have built a router in JSON! Basically, the entire router logic is represented as a piece of data. Browser var rpc = { name: &quot;add&quot;, args: [2,3,1] } fetch(&quot;http://localhost:3000&quot;, { method: &quot;POST&quot;, headers: { &#39;Accept&#39;: &#39;application/json&#39;, &#39;Content-Type&#39;: &#39;application/json&#39; }, body: JSON.stringify(rpc) ).then(function(res) { console.log(res.json()); }) Server // router.json [{ &quot;{{#if &#39;name&#39; in this}}&quot;: [{ &quot;{{#if name === &#39;add&#39;}}&quot;: &#39;add_service&#39; }, { &quot;{{#elseif name === &#39;subtract&#39;}}&quot;: [{ &quot;{{#if args.length === 2}}&quot;: &#39;subtract_service&#39; }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }] }] }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }] // express server app.post(&#39;/&#39;, (req, res) =&gt; { const Services = { add_service: function(){ return Array.prototype.slice .call(arguments) .reduce((a,b) =&gt; { return a+b; }, 0) }, subtract_service: function() { return arguments[0] - arguments[1] }, error_service: function() { return &#39;error&#39;; } } const name = ST.transform(require(&#39;./router.json&#39;), req.body); res.json(Services[name].apply(this, req.body.args)); }); 5.6.4 Routerless Server Let‚Äôs take the router example from right above. Since our router logic is just a JSON (router.json), we don‚Äôt even need it on the server side. What if we DON‚ÄôT keep router.json on the server, but send it from the browser? Browser var router = [{ &quot;{{#if &#39;name&#39; in this}}&quot;: [{ &quot;{{#if name === &#39;add&#39;}}&quot;: &#39;add_service&#39; }, { &quot;{{#elseif name === &#39;subtract&#39;}}&quot;: [{ &quot;{{#if args.length === 2}}&quot;: &#39;subtract_service&#39; }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }] }] }, { &quot;{{#else}}&quot;: &#39;error_service&#39; }]; var rpc = { name: &quot;add&quot;, args: [2,3,1], router: router } fetch(&quot;http://localhost:3000&quot;, { method: &quot;POST&quot;, headers: { &#39;Accept&#39;: &#39;application/json&#39;, &#39;Content-Type&#39;: &#39;application/json&#39; }, body: JSON.stringify(rpc) ).then(function(res) { console.log(res.json()); }) Server // express server app.post(&#39;/&#39;, (req, res) =&gt; { const Services = { add_service: function(){ return Array.prototype.slice .call(arguments) .reduce((a,b) =&gt; { return a+b; }, 0) }, subtract_service: function() { return arguments[0] - arguments[1] }, error_service: function() { return &#39;error&#39;; } } const name = ST.transform(req.body.router, req.body); res.json(Services[name].apply(this, req.body.args)); }); What‚Äôs going on here? We are looking at a server WITHOUT a router. Instead of implementing a router on the server, we send the router itself as part of a network request! This type of JSON-powered portability provides extreme flexibility when creating interfaces for microservices and RPC endpoints Also, remember that you can bake validation, conditionals, loops, etc. all in a single JSON IPC/RPC call, which makes it extremely powerful and efficient. 5.6.5 Jasonette Jasonette uses ja.js to: Transform an ‚Äúaction‚Äù JSON object into a native method call. Transform any client-side data into a view markup, and then into actual native view components. Here‚Äôs an example where we describe an ‚Äúaction‚Äù (function) in a JSON object: { &quot;type&quot;: &quot;$network.request&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;https://jsonplaceholder.typicode.com/posts&quot; }, &quot;success&quot;: { &quot;type&quot;: &quot;$render&quot;, &quot;options&quot;: { &quot;data&quot;: &quot;{{$jason}}&quot; } } } Every function (called ‚Äúaction‚Äù) consists of up to four attributes: &quot;type&quot;: Type of action to perform. Jasonette interprets this into an actual native method call. &quot;options&quot;: Arguments to send to the action. &quot;success&quot;: Success callback. You can chain another action here. &quot;error&quot;: Error callback. You can chain another action here. In above example we make a &quot;$network.request&quot; action call, with a payload of: { &quot;options&quot;: { &quot;url&quot;: &quot;https://jsonplaceholder.typicode.com/posts&quot; } } This actually translates to a native Objective-c function call, and when it succeeds, it triggers its ‚Äúsuccess‚Äù callback which is another action: { &quot;success&quot;: { &quot;type&quot;: &quot;$render&quot;, &quot;options&quot;: { &quot;data&quot;: &quot;{{$jason}}&quot; } } } This is where ja.js comes in. Whenever an action call is made, Jasonette automatically fills the $jason variable with the return value from its preceding action ($network.request) and runs a transform, thereby implementing an actual function call. "],
["tools.html", "6 Tools 6.1 Jason App { ¬∑·¥•¬∑} 6.2 Code Snippets", " 6 Tools The following tools help developers to be more efficient in using Jasonette technology. 6.1 Jason App { ¬∑·¥•¬∑} Jason is a single app that lets you summon and bookmark multiple Jasonette apps simply by entering the JSON url, without building your own physical app or setting up development environment. It‚Äôs good for using as a container for single purpose apps or quick disposable apps, prototyping, beta testing, etc. 6.1.1 How is related to Jasonette? Maybe it‚Äôs easier if we put it this way: Jason { ¬∑·¥•¬∑} is like a Web browser, Jasonette { ÀÉÃµÃë·¥•ÀÇÃµÃë} is the Web browser‚Äôs engine. 6.1.2 What is it? Jason is an app that lets you bookmark and run multiple Jasonette apps without building your own. Jason itself is built with Jasonette. Jasonette is the open source app framework that lets you build your own publishable app. 6.1.3 When to use? When you need to‚Ä¶ Jason Start building without a development environment like XCode or Android Studio. Useful for quick prototyping. Beta test your Jasonette app with friends before submitting to the app store. Just need to share URL. Bookmark and run multiple Jasonette apps from a single app. Build apps that can‚Äôt be / don‚Äôt need to be published to the App Store Disposable apps, private apps. Jasonette When you need to package up an app so you can publish to the App Store. 6.1.4 How to Install Installing Jason App can be achieved by using a pre-build APK or a custom made APK. 6.1.4.1 Default Installation (Android Only) You can download the APK for the default Jasonette components here: https://github.com/jasonelle/jasonelle/releases/download/v1.0/jasonapp.apk. An Android Package Kit (APK for short) is the package file format used by the Android operating system for distribution and installation of mobile apps. Just like Windows (PC) systems use an .exe file for installing software, the APK does the same for Android. When you download an APK online, you‚Äôre essentially getting an app. Most users get apps from the Google Play Store, without ever seeing the word APK. But there are occasions when you would want to do otherwise. 6.1.4.1.1 How to install an APK from your Android device You can also install APK files from your browser on your Android smartphone or tablet. Just open your browser here https://github.com/jasonelle/jasonelle/releases/download/v1.0/jasonapp.apk, you should then be able to see it downloading on the top bar of your device. Once it‚Äôs downloaded, open Downloads, tap on the APK file, and tap Yes when prompted. The app will begin installing on your device. Simple. 6.1.4.1.2 Troubleshooting Before you can install it on your phone you will need to make sure that third-party apps are allowed on your device. Go to Menu &gt; Settings &gt; Security &gt; and check Unknown Sources to allow your phone to install apps from sources other than the Google Play Store. Android 8 Oreo and 9 Pie do things a little differently. Rather than check a global setting to allow installation from unknown sources, you‚Äôll be you‚Äôll be prompted to allow your browser or file manager to install APKs the first time you attempt to do so. More info at: https://www.androidpit.com/android-for-beginners-what-is-an-apk-file. 6.1.4.2 Custom Installation (Android/iOS) This installation is recommended when you want to use the latest code base or simply apply custom made patches (Example: Additional Components not available in default installation). Installing Jason App is similar to creating a custom Jasonette App. The main difference is that you only made this once and you will be ready to start testing your JSONs. Download Jasonette from the releases repository (https://github.com/jasonelle/jasonelle/releases). Add the Jason url to the project. Build it in XCode or Android Studio. The url you must use is https://raw.githubusercontent.com/jasonelle/docs/develop/examples/jasonette/apps/jason-app/index.json Jason App in Xcode The complete source code is in the following directory https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/jason-app If you need futher documentation please visit the old docs setup guide. https://jasonelle.com/jasonette-old-docs/ios/ https://jasonelle.com/jasonette-old-docs/android/ 6.1.4.2.1 Troubleshooting On iOS if you use this method you have to reinstall the app in the next 7 days or it will stop working. If you want to use the app longer you have to use https://developer.apple.com/testflight/, but that requires a $99 USD per year for an Apple developer account. 6.1.5 How to Use Once you installed Jason App in your device, start adding the URLs that contains a valid JSON App. You can use this by typing the url or scaning a Qr code image. 6.2 Code Snippets Various code snippets were created by the community to enable autocompletion for $jason files. Name Author Repo Backup Repo VSCode Snippets Felipe Mullen https://github.com/jasonelle/vscode-jasonette-snippets https://github.com/jasonelle/vscode-jasonette-snippets Sublime Text Snippets Barry Anders https://github.com/BarryMode/jasonette-completions https://github.com/jasonelle/sublime-jasonette-snippets Cloud9 Snippets Lixas https://github.com/lixas/c9JasonetteSnippets https://github.com/jasonelle/cloud9-jasonette-snippets "],
["jasonette-tutorials.html", "7 Jasonette Tutorials 7.1 Build a QRCode/Barcode scanning app with 26 lines of JSON 7.2 Turn Your Website into a Mobile App with 7 Lines of JSON", " 7 Jasonette Tutorials The following tutorials are using Jasonette as the main technology. 7.1 Build a QRCode/Barcode scanning app with 26 lines of JSON This tutorial was posted by Ethan on Medium https://medium.com/(???) Nowadays we see QR code everywhere. We see it on a billboard, we see it embedded in product packaging, we use it to share Bitcoin public key. QR code is like a 2D version of barcode. As a publisher, you can pack all kinds of data in it as an image, and as a consumer you can simply scan the QR code to extract whatever is stored in the code. Both web.jasonette.com and jasonbase.com websites incorporate QR Code scanning, so you can just open your JASON app and scan the QR code to automatically open the app. Scan the QR code from JASON app to load the app But you can do much more than just storing a URL in a QR code. Let‚Äôs take a look at how you can implement the QR code feature for your app too. Like any other features on Jasonette, it‚Äôs all built into Jasonette, so you don‚Äôt need to do anything. You just need to load a JSON markup that instructs Jasonette to scan QR code. 7.1.1 How to implement You can implement barcode &amp; QR code scanning using a newly added API called $vision. Here‚Äôs how you implement them: 1 - Include back facing camera as background, as follows: { &quot;$jason&quot;: { &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 2 - Wait for $vision.ready event and call $vision.scan action You need to wait for the camera to be ready before calling the scan action. { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$vision.ready&quot;: { &quot;type&quot;: &quot;$vision.scan&quot; } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 3 - Now wait for $vision.onscan event This will be triggered once when the camera scans a new barcode. The event will return the data inside $jason, which you can parse to use it for your own purpose, like below: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$vision.ready&quot;: { &quot;type&quot;: &quot;$vision.scan&quot; }, &quot;$vision.onscan&quot;: { &quot;type&quot;: &quot;$util.alert&quot;, &quot;options&quot;: { &quot;title&quot;: &quot;Scanned&quot;, &quot;description&quot;: &quot;{{$jason.content}}&quot; } } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 7.1.2 Simple and Flexible, works on both iOS and Android. Believe it or not, I have just introduced you to the entirety of the $vision API. No need to write native code or install additional features, it‚Äôs already all built into Jasonette-iOS and Jasonette-Android. Just load the JSON markup from Jasonette and it should just work. This works not just for the QR code, but also for regular ‚Äúone dimensional‚Äù barcode we‚Äôre all familiar with. Just like any other Jasonette actions, you can chain the scanned data with other Jasonette action to achieve whatever you need to build. For example you could: Automatically open a web page by scanning a QR code containing a URL Render any UI component using $render and passing the scanned data to a template. etc. Below you see another example which scans barcode and qrcode, and displays the content on the screen in realtime: Check out the code for above example in Jasonpedia. 7.1.3 Conclusion QR code is really cool, and Jasonette makes it super easy to implement it just by writing a few lines of JSON markup. Not only is it easy, but it‚Äôs also very flexible, since you can pass the return value to any other action to build whatever you want. Please play with it and share if you come up with any cool examples. Have fun! 7.2 Turn Your Website into a Mobile App with 7 Lines of JSON A New Approach for Blending Web Engine into Native Apps This tutorial was posted by Ethan on FreeCodeCamp https://medium.freecodecamp.org/how-to-turn-your-website-into-a-mobile-app-with-7-lines-of-json-631c9c9895f5. What if I told you the 7 lines of JSON above, colored in orange is all you need to turn a website into a mobile app? No need to rewrite your website using some framework API just to make it behave like a mobile app. Just bring your existing website as is, and blend it into a native app with a simple URL reference. And what if, just by tweaking the JSON markup a bit, you can access all the native APIs, native UI components, as well as native view transitions out of the box? Here‚Äôs what a minimal example looks like in action: Notice how I‚Äôve embedded a github.com web page but the rest of the layout is all native UI components, such as the navigation header and the bottom tab bar. And the transition is automatically native without you having to rewrite the website using any APIs. Before I explain how, you may ask: ‚ÄúThat‚Äôs cool, but can you do anything meaningful other than just displaying the web page in a native app frame?‚Äù Great question, because that‚Äôs the main topic of this post. All you need to do is create a seamless 2-way communication channel between the web view and the app, so the parent app can trigger any JavaScript functions inside the web view and the web view can reach outside to call native APIs. Here‚Äôs one such example: Note that this view contains: Native navigation header, complete with built-in transition functionality A Web view, which embeds a QR code generator web app A native chat input component at the bottom All this can be described by just tweaking some of the JSON markup attributes we saw above. Finally, note that the QR code changes as you enter something from the chat input. The chat input triggers a JavaScript function inside the QR code web app that re-generates the image. No app development framework has tried to fundamentally solve this problem of ‚Äúseamless integration of web view into native apps‚Äù because they‚Äôre all focused on picking either 100% native or 100% HTML5 side. Whenever you hear someone talk about the future of mobile apps, you would probably hear them talk about ‚ÄúWill it be the HTML5 approach that wins out? Or will it be native?‚Äù. None of them see native and html as something that could co-exist and furthermore, create synergy and achieve things that are not easily possible otherwise. In this article I‚Äôm going to explain: Why blending web engine and native components is often a good idea. Why a seamless integration of HTML and Native is not easy, and how I implemented one. Most importantly, how YOU can use it to build your own app instantly. 7.2.1 Why would you use HTML in a native app? Before we go further, let‚Äôs first discuss whether this is even a good idea, and when you may want to take this approach. Here are some potential use cases: Use Web Native Features Some parts of your app may be better implemented using the web engine. For example, Websocket is a web-native feature that‚Äôs designed for the web environment. In this case it makes sense to use the built-in web engine (WKWebView for iOS and WebView for Android) instead of installing a 3rd party library that essentially ‚Äúemulates‚Äù Websocket. No need to install additional code just to do something that you can do for free, which brings us to the next point. Avoid Large Binary Size You may want to quickly incorporate features that will otherwise require a huge 3rd party library. For example, to incorporate a QR code image generator natively, you will need to install some 3rd party library which will increase the binary size. But if you use the web view engine and a JavaScript library through a simple &lt;script src&gt;, you get all that for free, and you don‚Äôt need to install any 3rd party native libraries. No Reliable Mobile Library Exists For some cutting edge technologies, there is no reliable and stable mobile implementation yet. Fortunately most of these technologies have web implementations, so the most efficient way to integrate them is to use their JavaScript library. Build part-native, part-web-based apps Many new developers looking to port their website into a mobile app get discouraged or overwhelmed when they find out some of their existing website features are too complex to quickly rewrite from scratch for each mobile platform. For example, you may have a single web page that‚Äôs too complex to immediately convert to a mobile app, but the rest of your website may be easily converted. In this case, it would be nice if there was a way to build most of the app natively, but for that particular complex web page, somehow seamlessly integrate it into the app as HTML. 7.2.2 How does it work? Jasonette Jasonette is an open source, markup-based approach to building cross-platform native apps. It‚Äôs like a web browser, but instead of interpreting HTML markup into web pages, it interprets JSON markup into native apps on iOS and Android. Just like how all web browsers have exactly the same code but can deliver you all kinds of different web apps by interpreting various HTML markup on demand, all Jasonette apps have exactly the same binary, and it interprets various JSON markup on demand to create your app. The developers never need to touch the code. Instead, you build apps by writing a markup that translates to native app in real-time. You can learn more about Jasonette here. While Jasonette at its core is all about building native apps, this particular article is about integrating HTML into the core native engine, so let‚Äôs talk about that. Jasonette Web Container Native apps are great but sometimes we need to make use of web features. But integrating web views into a native app is a tricky business. A seamless integration requires: Web view should be integrated as a part of native layout: The web view should blend into the app as a part of the native layout and is treated just like any other native UI components. Otherwise it will feel clunky, and it will feel exactly like what it is a website. Parent app can control child web container: The parent app should be able to freely control the child web view. Child web container can trigger native events on the parent app: The child app should be able to trigger the parent app‚Äôs events to run native APIs. These are a lot of work, so I first worked on only the first piece of the puzzle simply embedding a web container into native layout and released it as version 1. This was already pretty useful, but it still had the limitation of being non-interactive. The parent app couldn‚Äôt control the child web container, and the child couldn‚Äôt notify the parent of any event, keeping the web container completely isolated from the outside world. Jasonette Web Container 2.0: Make it Interactive After releasing version 1, I experimented with the second piece of the puzzle adding interactivity to the web container. The next section explains the solutions that were added to make the previously-static web containers interactive, making them significantly more powerful. 7.2.3 Implementation: Interactive Web Container 1 - Load by URL Problem Previously in version 1, to use web container as a background view component, you had to first set the $jason.body.background.type to &quot;html&quot; and then hard-code the HTML text under $jason.body.background.text attribute like this: { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;text&quot;: &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; } } } } Naturally people wanted to be able to instantiate the container using simply a web URL instead of having to hardcode the entire HTML text in a single line. Solution Web container 2.0 has added the url attribute. You can embed a local file:// HTML like this (it loads from the local HTML file you ship with the app): { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot; } } } } Or embed a remote http[s]:// URL like this (it loads from a remote HTML): { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;https://news.ycombinator.com&quot; } } } } 2 - Parent App &lt;=&gt; Web Container Communication Problem Previously, web containers were only for displaying content, and not interactive. This meant NONE of the following was possible: Jasonette =&gt; Web Container: Call JavaScript functions inside the web container from Jasonette. Web Container =&gt; Jasonette: Call native API from web container code. All you could do was display the web container. This was similar to how you would embed an iframe in a web page, but the main web page had no access to what was inside the iframe. Solution The whole point of Jasonette is to design a standard markup language to describe cross platform mobile apps. In this case, we needed a markup language that could comprehensively describe communications between the parent app and the child web container. To achieve this, I came up with a JSON-RPC based communication channel between the parent app and the child web container. Since everything on Jasonette is expressed in JSON objects, it made perfect sense to use the JSON-RPCstandard format as the communication protocol. To make a JavaScript function call into the web container, we declare an action called $agent.request: { &quot;type&quot;: &quot;$agent.request&quot;, &quot;options&quot;: { &quot;id&quot;: &quot;$webcontainer&quot;, &quot;method&quot;: &quot;login&quot;, &quot;params&quot;: [&quot;username&quot;, &quot;password&quot;] } } $agent.request is the native API that triggers a JSON-RPC request into the web container. To use it, we must pass an options object as its parameter. The options object is the actual JSON-RPC request that will be sent to the web container. Let‚Äôs look at what each attribute means: id: Web container is built on top of a lower level architecture called agent. Normally you can have multiple agents for a single view, and each agent can have its unique ID. But Web container is a special type of agent which can only have the id of $webcontainer, which is why we use that ID here. method: The JavaScript function name to call. params: The array of parameters to pass to the JavaScript function. The full markup would look something like this: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$load&quot;: { &quot;type&quot;: &quot;$agent.request&quot;, &quot;options&quot;: { &quot;id&quot;: &quot;$webcontainer&quot;, &quot;method&quot;: &quot;login&quot;, &quot;params&quot;: [&quot;alice&quot;, &quot;1234&quot;] } } } }, &quot;body&quot;: { &quot;header&quot;: { &quot;title&quot;: &quot;Web Container 2.0&quot; }, &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot; } } } } This markup is saying: When the view loads ($jason.head.actions.$load), make a JSON-RPC request into the web container agent ($agent.request) where the request is specified under options. The web container is defined under $jason.body.background, which in this case loads a local file called file://index.html. It will look for a JavaScript function called login and pass the two arguments under params ( &quot;alice&quot; and &quot;1234&quot;). login(&quot;alice&quot;, &quot;1234&quot;) I‚Äôve only explained how the parent app can trigger the child web container‚Äôs JavaScript function calls, but you can also do the opposite and let the web container trigger the parent app‚Äôs native API. To learn more, check out the agent documentation. Example Let‚Äôs come back to the QR code example I briefly shared above: The footer input component is 100% native. The QR code is generated by the web container as a web app. When a user enters something and presses ‚ÄúGenerate,‚Äù it calls $agent.request action into the web container agent, calling the JavaScript function ‚Äúqr‚Äù. You can check out the example here. 3 - Script Injection Problem Sometimes you may want to dynamically inject JavaScript code into the web container AFTER it‚Äôs finished loading the initial HTML. Imagine you want to build a custom web browser app. You may want to inject your own custom JavaScript into every web view to customize the web view‚Äôs behavior, kind of like how web browser extensions work. Even if you‚Äôre not building a web browser, you may want to use the script injection method whenever you want a custom behavior for a URL whose content you have no control over. The only way to communicate between the native app and the web container is through the $agent API. But if you can‚Äôt change the HTML content, the only way to add the $agent interface into the web container is through dynamic injection. Solution As mentioned in the previous section, the $jason.body.background web container is just another agent. This means you can use the same $agent.inject method available to regular agents. 4 - URL Click Handling In the past, there were only two ways a web container could handle link clicks: Readonly: Treat the web container as readonly and ignore all events such as touch or scroll. All web containers are readonly unless you tell them to behave like a regular browser, as described below. Regular Browser Behavior: Let users interact with the page by behaving like a normal browser. You declare it by setting &quot;type&quot;: &quot;$default&quot; as its action attribute. Problem Both are ‚Äúall or nothing‚Äù solutions. In the ‚ÄúReadonly‚Äù case, all your interactions are completely ignored by the web container. In the ‚ÄúRegular Browser Behavior‚Äù case, the web container functions literally as a browser. When you click a link, it would just send you to that link by refreshing the page just like a web page. There was no way to hijack the click and call some native API. Solution With the new web container, you can now attach any action on the $jason.body.background web container to handle link click events. Let‚Äôs look at an example: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;displayBanner&quot;: { &quot;type&quot;: &quot;$util.banner&quot;, &quot;options&quot;: { &quot;title&quot;: &quot;Clicked&quot;, &quot;description&quot;: &quot;Link {{$jason.url}} clicked!&quot; } } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;displayBanner&quot; } } } } } Here we have attached &quot;trigger&quot;: &quot;displayBanner&quot; to the web container. This means that when a user clicks any link in the web container, it will trigger displayBanner action instead of letting the web view handle it. Also, if you look at the displayBanner action, you‚Äôll notice the $jason variable. In this case, the clicked link will be passed through the $jason variable. For example, if you clicked a URL named &quot;https://google.com&quot;, the $jason will have the following value: { &quot;url&quot;: &quot;https://google.com&quot; } This means you can selectively trigger different actions by checking the $jason.url value. Let‚Äôs take another example where we implement a custom web browser: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;handleLink&quot;: [{ &quot;{{#if $jason.url.indexOf(&#39;signin&#39;) !== -1 }}&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;file://key.html&quot; } } }, { &quot;{{#else}}&quot;: { &quot;type&quot;: &quot;$default&quot; } }] } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;handleLink&quot; } } } } } We test if the URL contains the string signin and then run two different actions depending on the result. If it contains signin, it opens a new view to take care of signing in natively. If it doesn‚Äôt contain signin, just run the &quot;type&quot;: &quot;$default&quot; action so that it behaves like a regular browser. 7.2.4 Example Usage Building a custom web browser We can now take advantage of the fact that the new web container can: Take a url attribute to load itself, functioning as a full-fledged browser Selectively handle link clicks depending on the URL We can even build a custom web browser app with just a dozen lines of JSON. Since we can now hijack every link click, we can take a look at $jason.url and run whatever actions we want depending on the URL. For example, take a look at the example below: On the left side we see that clicking a link behaves like a regular browser (&quot;type&quot;: &quot;$default&quot;) On the right side we see that clicking a link does a native transition to another JASON view. All this can be achieved by selectively triggering different actions based on $jason.url. Step 1. Attach an action named visit to the web container like this: { ... &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;https://news.ycombinator.com&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;visit&quot; } } } } Step 2. Run relevant actions inside visit, based on $jason.url In the following code, we‚Äôre checking if $jason.url matches newest, show, ask, and so on (they‚Äôre the top menu item links). If they do, we let the web container behave like a regular browser by setting &quot;type&quot;: &quot;$default&quot;. If they don‚Äôt match the pattern, we make a native $href transition to a new view and pass the clicked link as a parameter. ... &quot;actions&quot;: { &quot;visit&quot;: [ { &quot;{{#if /\\\\/(newest|show|ask)$/.test($jason.url) }}&quot;: { &quot;type&quot;: &quot;$default&quot; } }, { &quot;{{#else}}&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;https://jasonette.github.io/Jasonpedia/webcontainer/agent/hijack.json&quot;, &quot;preload&quot;: { &quot;background&quot;: &quot;#ffffff&quot; }, &quot;options&quot;: { &quot;url&quot;: &quot;{{$jason.url}}&quot; } } } } ] }, Check out the full JSON markup for the web browser here (it‚Äôs only 48 lines!). Instant ‚ÄúHybrid‚Äù App When people normally talk about ‚Äúhybrid‚Äù apps, they mostly mean HTML web apps wrapped inside a native app frame. But that‚Äôs not what I mean here. When I say ‚ÄúHybrid,‚Äù I mean a truly hybrid app, where one app can have multiple native views and multiple web-based views simultaneously. Also where one view can have multiple native UI components and a web container rendered in the same native layout. The cross-over between web-based view and native view should be so seamless that it‚Äôs hard to tell where one starts and ends. In this example, I‚Äôve created an app that displays jasonbase.com in a web container as the home view. Jasonbase is a free JSON hosting service I built to easily host JSON markup for Jasonette apps. Naturally, it‚Äôs just a website, but I have embedded it in Jasonette so that when you click the link, instead of opening a web page, it makes a native $href transition to a native JASON view. I didn‚Äôt have to touch any of Jasonbase.com‚Äôs code to build this app. I simply embedded the website into Jasonette as a web container, and hijacked the link clicks to handle them natively, so it can do all the native stuff like triggering native APIs and making native transitions. You can check out the code here. 7.2.5 Conclusion In my opinion, what makes all this work fabulously is that everything is taken care of on the framework level. All the hard work is taken care of behind the scenes. Instead of putting the burden on the app developers to implement all of the following from scratch: Embed a webview into native layout. Create a JavaScript bridge so the app can make function calls into the web view. Creating a native event handling architecture so the web view can trigger native events on the parent app. The solution was to create an abstraction made up of: Declarative Markup Language: for describing how to embed a web view into a native app. Communication Protocol (JSON-RPC): to allow dead-simple interactions between the app and its child web views. I don‚Äôt claim this approach to be the ultimate solution to solve everything, but I‚Äôm happy to say that this has been a great solution for my own use case. I was trying to build an app that builds on a super edge technology which has no stable and reliable mobile implementations (and it‚Äôs not clear if there ever will be a mobile implementation due to the protocol‚Äôs nature). Thankfully it had JavaScript implementations so I could easily integrate it into the app without hassle. Overall, it‚Äôs been great and I‚Äôm satisfied with how it turned out. The documentation is up to date to reflect all the new features, so feel free to dig in and play around. Disclaimer: With great power comes great responsibility I would like to end with a disclaimer: as great as this newly found power is, I think you need to keep a balance to build an app with a great user experience. Some may take this and build an entire app using web views only, but then you will end up with an app that‚Äôs basically just a website, which defeats the purpose of building a dedicated app. I emphasize that I‚Äôm not saying you should always build apps with both HTML and native. I am saying this can be very useful for many people in different situations. Just don‚Äôt go overboard with it. Follow Along to Learn More There are many different configurations in which the Jasonette native core and its child web container can communicate to get things done in creative and powerful ways, and this post is just scratching the surface. "],
["how-to-guides.html", "8 How To Guides 8.1 How to Know the Operating System 8.2 How to Open Native Maps App 8.3 How to Call/SMS/Facetime a Phone Number 8.4 How to Send Emails 8.5 How to Add Events to Calendar 8.6 How to Overwrite links in a Website", " 8 How To Guides Small tips and tricks. 8.1 How to Know the Operating System If you need to check the operating system before executing some code. You could use the $env property to obtain details of the operating system. {{#if $env.device.os.name === 'ios'}}: Evals to true if the operating system is iOS. {{#if $env.device.os.name === 'android'}}: Evals to true if the operating system is Android. 8.2 How to Open Native Maps App If you want to open the native map view you need to simply use $href with the special url maps.apple.com (iOS) or maps.google.com. (Android). And the app view. Put this code inside the actions object. { &quot;open_map&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;view&quot;: &quot;app&quot;, &quot;transition&quot;: &quot;modal&quot;, &quot;url&quot;: [{ &quot;{{#if $env.device.os.name === &#39;ios&#39;}}&quot;: &quot;https://maps.apple.com?ll=-33.44402500439274,-70.65428849999995&amp;z=14&quot; }, { &quot;{{#else}}&quot;: &quot;https://maps.google.com?center=-33.44402500439274,-70.65428849999995&amp;zoom=14&quot; } ] } } } And call it with trigger. { &quot;action&quot;: { &quot;trigger&quot; : &quot;open_map&quot; } } 8.3 How to Call/SMS/Facetime a Phone Number If you want to call/sms a phone number you can use the $href with the tel: or sms: and the app view. { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;tel:18888888888&quot;, &quot;view&quot;: &quot;app&quot;, &quot;transition&quot;: &quot;modal&quot; } } Note: This feature only works on devices that can make app calls. So simulators like the iOS can‚Äôt test this. Use a real smartphone for this functionality. Possible Values (Some of them): sms:, tel:, mailto:, facetime:, facetime-audio:. Apple Docs: https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899. 8.4 How to Send Emails The principle is the same as calling a phone number. Use mailto: address in the url to trigger the mail app. { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;mailto:hi@jasonelle.com&quot;, &quot;view&quot;: &quot;app&quot;, &quot;transition&quot;: &quot;modal&quot; } } RFC: https://www.ietf.org/rfc/rfc2368.txt 8.5 How to Add Events to Calendar You can add events to the calendar by linking to an ics file and using the $href action with the app view. You can also use the web view to show the calendar details before adding it. This file can be stored (or generated) in a server or in local file://. { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;http://host/calendar.ics&quot;, &quot;view&quot;: &quot;app&quot;, &quot;transition&quot;: &quot;modal&quot; } } More info about the ics files https://tools.ietf.org/html/rfc5545. https://en.wikipedia.org/wiki/ICalendar. You can create ics files by using software like Apple Calendar, Google Calendar or any application that support this filetype. https://en.wikipedia.org/wiki/List_of_applications_with_iCalendar_support. 8.6 How to Overwrite links in a Website If you have a $webcontainer agent in your app. You can listen to a href links and execute different native behaviours depending on the url provided. In the following example (created by user RAPOS) we can make a link url to trigger a phone call if the url contains tel prefix. Otherwise the ahref will follow the normal behaviour. With this method we can trigger any native functionality available. It is also configured the background color to be white, and the progress bar to be transparent. { &quot;$jason&quot;: { &quot;head&quot;: { &quot;title&quot;: &quot;Overwriting ahref behaviour&quot;, &quot;actions&quot;: { &quot;ahref_handler&quot;: [{ &quot;{{#if $jason.url.indexOf(&#39;tel&#39;) !== -1 }}&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;view&quot;: &quot;app&quot;, &quot;url&quot;: &quot;{{$jason.url}}&quot; } } }, { &quot;{{#else}}&quot;: { &quot;type&quot;: &quot;$default&quot; } }] } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;text&quot;: &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;&lt;a href=&#39;tel:987654321&#39;&gt;Call ME&lt;/a&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;ahref_handler&quot; }, &quot;style&quot;: { &quot;background&quot;: &quot;#ffffff&quot;, &quot;progress&quot;: &quot;rgba(0,0,0,0)&quot; } } } } } "],
["discussions.html", "9 Discussions 9.1 BeerJS - Chile - 2019 9.2 Building cross-platform mobile apps using nothing more than a JSON markup 9.3 Native Mobile View as Microservice 9.4 Apps for a Lifetime", " 9 Discussions Discussions and related info is dedicated to index and store links and other resources. 9.1 BeerJS - Chile - 2019 June 5th 2019, was made a presentation of Jasonelle in Santiago, Chile. The presentation slides and related code is stored in the following repository: https://github.com/jasonelle/beerjs 9.2 Building cross-platform mobile apps using nothing more than a JSON markup This article was written by Ethan on FreeCodeCamp. https://www.freecodecamp.org/news/how-to-build-cross-platform-mobile-apps-using-nothing-more-than-a-json-markup-f493abec1873/#.i83lzc4g9 For the past few months, I‚Äôve been working on a new way to build cross-platform, native iOS and Android apps called Jasonette. It lets you describe an entire app with nothing but a single JSON markup. If your app consists entirely of JSON, it can be treated like any other data. And it can be served remotely from the cloud on-demand. The app logic no longer needs to be hardcoded on the device, and you can update it as much as you want just by updating your JSON on the server-side. Your app will be freshly loaded from the server every time you open it. Jasonette has many different parts. You can express functions, templates, styles, and more all by using a JSON Markup. And as a result, you can write a super-sophisticated native mobile app in a fully Model ‚Äî View ‚Äî Controller (https://en.wikipedia.org/wiki/Model-view-controller) manner. In this post I‚Äôll show you specifically the ‚ÄúView‚Äù part: How Jasonette expresses various cross-platform UI patterns in JSON. How it implements these JSON-to-Native mappings internally. 9.2.1 Basic Structure Under the hood, Jasonette works similarly to a web browser. But instead of interpreting an HTML markup and drawing a web view, Jasonette fetches a JSON markup and constructs a native view, on-the-fly. The markup is just a JSON file that follows some predefined conventions. First of all, it starts with a $jason key, which has two children: head and body, and looks like this: { &quot;$jason&quot;: { &quot;head&quot;: { // ..metadata about the document... }, &quot;body&quot;: { // ..actual content to be displayed on the view.. } } } 9.2.2 Design Philosophy When I first started designing the JSON syntax for describing native views, I had a couple of constraints in mind: Native: There‚Äôs a reason why iOS and Android came up with their own native layout systems. The layout systems designed for the desktop era don‚Äôt always translate well to the small device world. The syntax should express the underlying layout in as mobile native manner as possible. Cross platform: Yet it needs to be cross platform. For example, iOS has something called autolayout (https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG) and visual format language (https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html) but these are not implemented natively on Android, so not the right solution. Simple yet expressive: It should be easily expressed in a simple JSON format and easy to compose into a sophisticated structure. When you take a look at how most mobile apps are built, they all boil down to a small number of common interface patterns: Vertically scrolling list Horizontally scrolling list Absolute positioning Grid Let‚Äôs take a look at the first three, since they are most widely used. 9.2.3 Sections ‚Äî Describing scrolling lists The most frequently used UI pattern is scrolling lists. On Jasonette we call them sections. There are two types of sections: Vertical and Horizontal. Vertical sections scroll vertically, and horizontal sections horizontally. Vertical Section Horizontal Section 9.2.3.1 Implementation ‚Äî Vertical Sections This is probably the most frequently used UI for displaying data on mobile devices. On iOS, Jasonette implements this with UITableView (https://developer.apple.com/reference/uikit/uitableview). On Android it‚Äôs implemented with RecyclerView (https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html). { &quot;body&quot;: { &quot;sections&quot;: [{ &quot;items&quot;: [{ &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Item 1&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Item 2&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Item 3&quot; }] }] } } On iOS, above JSON markup creates a UITableView (https://developer.apple.com/reference/uikit/uitableviewcell) with three UITableViewCells (https://developer.apple.com/reference/uikit/uitableviewcell), each of which contains a UILabel (https://developer.apple.com/reference/uikit/uilabel), with corresponding text attributes. On Android, it creates a RecyclerView with three items, each of which is a TextView (https://developer.android.com/reference/android/widget/TextView.html) that displays the corresponding text attributes. All of these are constructed programmatically without any use of Storyboards in iOS (https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Storyboard.html) or XML layout files (Android) (https://developer.android.com/guide/topics/resources/layout-resource.html) in order to make sure every detail is programmable dynamically. 9.2.3.2 Implementation ‚Äî Horizontal Sections Syntax-wise, horizontal sections are not much different, all you need to do is set the type as ‚Äúhorizontal‚Äù, and the items flow horizontally. { &quot;body&quot;: { &quot;sections&quot;: [{ &quot;type&quot;: &quot;horizontal&quot;, &quot;items&quot;: [{ &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Item 1&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Item 2&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Item 3&quot; }] }] } } Note The syntax for the horizontal section is simple, but internally it‚Äôs actually quite complex. Horizontal sections on iOS were implemented with UICollectionView (https://developer.apple.com/reference/uikit/uicollectionview). It‚Äôs a well-known technique, but basically a horizontally scrolling UICollectionView is embedded into its parent UITableView (which scrolls vertically). And on Android, it‚Äôs implemented in a similar manner, but using nested RecyclerViews instead. 9.2.4 Items ‚Äî Describing layout within each scrolling unit Now that we understand how the top level view is structured, let‚Äôs look at items. Each section is made up of multiple units of scrollable items. Note that each item has a fixed dimension and nothing inside the item itself scrolls. An item can be: Just a single component like a label, image, button, textarea, etc. A combination of all of those components. Implementing this part was not as straight-forward as the sections implementation, because I had to choose a cross-platform, native, simple, and expressive way to form a super-sophisticated layout. Thankfully, iOS and Android have very similar native layout systems called UIStackView (https://developer.apple.com/reference/uikit/uistackview) and LinearLayout (https://developer.android.com/reference/android/widget/LinearLayout.html), respectively. And these layout schemes in turn are similar to CSS Flexbox (https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes), so I would say it‚Äôs as cross-platform as it can get. Lastly, these layout systems are infinitely composable. As seen below, you can create a vertical layout, a horizontal layout, or nest a vertical layout within a horizontal layout, and so forth, recursively. To create a vertical layout, you would set the type as vertical, and then set its components: { &quot;items&quot;: [{ &quot;type&quot;: &quot;vertical&quot;, &quot;components&quot;: [{ &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;First&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Second&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Third&quot; }] }] } Same thing with horizontal layout. Just set the type as horizontal instead: { &quot;items&quot;: [{ &quot;type&quot;: &quot;horizontal&quot;, &quot;components&quot;: [{ &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;http://i.giphy.com/LXONhtCmN32YU.gif&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Rick&quot; }] }] } Nesting layouts is as simple as specifying a layout as another layout‚Äôs component. { &quot;items&quot;: [{ &quot;type&quot;: &quot;horizontal&quot;, &quot;components&quot;: [{ &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;http://i.giphy.com/LXONhtCmN32YU.gif&quot; }, { &quot;type&quot;: &quot;vertical&quot;, &quot;components&quot;: [{ &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;User&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Rick&quot; }] }] }] } I have not talked about the styling feature here for the sake of brevity, but you can style each individual component as well as the layout itself to make sure the layout looks exactly like you wanted. All you need to do is add style objects describing font, size, width, height, color, background, corner_radius, opacity, etc. 9.2.5 Layers ‚Äî AKA ‚Äúabsolute positioning‚Äù Sometimes you may want to position items at exactly certain parts of the screen without scrolling. In CSS-terms we would call this ‚Äúabsolute positioning‚Äù. Jasonette supports this through what‚Äôs called layers. Currently layer supports two types of child components: image and label. You can place these components anywhere you desire on the screen this way. Here‚Äôs an example: A Jasonette app with layer items In this example, we have two labels (the temperature and the weather messages) and an image (the camera icon) on the screen, whose coordinates have been explicitly set to make sure they stay in place without scrolling. The markup would look something like this: { &quot;$jason&quot;: { &quot;body&quot;: { &quot;style&quot;: { &quot;background&quot;: &quot;camera&quot; }, &quot;layers&quot;: [{ &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;22¬∞C&quot;, &quot;style&quot;: { &quot;font&quot;: &quot;HelveticaNeue-Light&quot;, &quot;size&quot;: &quot;20&quot;, &quot;top&quot;: &quot;50&quot;, &quot;left&quot;: &quot;50%-100&quot;, &quot;width&quot;: &quot;200&quot;, &quot;align&quot;: &quot;center&quot; } }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;few clouds&quot;, &quot;style&quot;: { &quot;font&quot;: &quot;HelveticaNeue&quot;, &quot;size&quot;: &quot;15&quot; } }, { &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;https://s3.amazonaws.com/.../camera%402x.png&quot;, &quot;style&quot;: { &quot;bottom&quot;: &quot;100&quot;, &quot;width&quot;: &quot;30&quot;, &quot;color&quot;: &quot;#ffffff&quot;, &quot;right&quot;: &quot;30&quot; } }] } } } Amazingly enough, this is all you need to know in order to build any kind of sophisticated view you can imagine on mobile devices. Just like you can build anything with simple lego blocks, you can compose these basic components and layouts in different ways to create any sophisticated view. Here are some examples, 100% built by composing aforementioned UI elements: Instagram UI (https://github.com/jasonelle/docs/tree/master/examples/jasonette/apps/instagram) Twitter UI (https://github.com/jasonelle/docs/tree/master/examples/jasonette/apps/twitter) 9.2.6 Beyond Views If you read this far, you may be either thinking: ‚ÄúWow cool! I wanna try this!‚Äù, or ‚ÄúYeah you can probably build a toy app, but no way you can build a production app using this way!‚Äù. Like I briefly mentioned above, this is just the ‚ÄúView‚Äù part of Jasonette, which is the simplest part. But what‚Äôs really powerful about Jasonette is that you can actually go much further and write a full declarative program in JSON. You can attach actions to UI elements, which get triggered when a user touches them. You can also trigger these actions one after another via success/error callbacks. You can also listen to certain events and automatically trigger these actions. Just like this, when you can describe not just a ‚ÄúView‚Äù but also the ‚ÄúModel‚Äù and the ‚ÄúController‚Äù logic (all in JSON), you can do anything. 9.2.7 What is possible? Since all you need is a server that sends JSON, Jasonette is completely platform agnostic. There is no proprietary server technology you need to depend on. All you need is JSON. And JSON can come from anywhere, from local device, to remote servers, to even a Raspberry pi! (https://www.raspberrypi.org/documentation/remote-access/web-server/nginx.md). Have a web app? : If you already have a web app, you can instantly build a mobile native app for your Node.js app, Rails app, Django app, PHP app, or really any web app, just by making requests to your API endpoint. You don‚Äôt even need a server : Since you can fit an entire model-view-controller in a single, self-contained JSON file, you can pretty much store and serve it from anywhere. You can even create an app from a static JSON file served from a Pastebin or Github!. Turn any HTML website into an app : Jasonette has a powerful HTML-to-JSON parser powered by the cheerio library which lets you transform any HTML into a JSON object. And you already know what we can do when we have JSON ‚Äî you can build a native view from the transformed JSON! This way, you can build a native app from a website that doesn‚Äôt even have an API. Of course, the recommended way is to use JSON whenever you can, but this is really cool regardless. I can go on forever, but here are some examples: A photo sharing app that lets you take a photo using the device camera and upload it to S3, and then post the entry to your own server, creating a feed: https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/s3-upload-example S3 Upload Example A Node.js powered Eliza Chatbot app for iOS and Android: https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/eliza-example Eliza Example A Microblog app, complete with session management: https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/token-authentication-example A remote control app for Slack bots: http://jasonelle.com/jasonette-old-blog/2017/01/17/build-a-slackbot-with-jasonette/ https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/coffee-app An example app that turns an HTML web page into JSON and then turns it into a native app: https://github.com/jasonelle/docs/tree/develop/examples/jasonette/apps/iosdevweekly iOS Dev Weekly 9.2.8 Conclusion Jasonette is a young project. I open-sourced the iOS version in late 2016, and the Android version a month later. But it has already grown into a vibrant community of contributors and makers and is under active development. I hope this technology will empower anyone (not just developers) to build apps effortlessly. 9.3 Native Mobile View as Microservice This article was published by Ethan on https://medium.com/(???). How sandboxed views talk to each other in Jasonette. Jasonette takes security very seriously. The entire architecture was built on a sandbox model that took inspiration from web browsers and applied to mobile context. Each view is completely sandboxed but they can communicate with other views through predefined protocols, resembling how microservices work (https://en.wikipedia.org/wiki/Microservices). In this post I will explain: How the sandbox model works in Jasonette. How two views can communicate back and forth using $href and $ok action protocols. 9.3.1 How Sandbox Model Works in Jasonette If a language encourages certain design patterns that are insecure, regardless of how secure the low level architecture is, we should consider the language insecure. For example, the language could facilitate a way to build an entire mobile app as a SINGLE view, based on highly inter-wined modules with complex dependency graph. This would force anyone who wants to understand and audit the code to understand the entire app as a whole. This means fewer people will even attempt to do something like this. With fewer eyeballs, the application is less secure. Therefore it is a good idea to break an app out to multiple views, each of which performs an atomic task, and can communicate with one another in a loosely coupled manner. To break an app out into multiple units Jasonette takes the following approach: Sandboxed Containers: Each View is a sandboxed container. One view can‚Äôt manipulate another view. A view can also contain child containers like agents and web containers, which are also sandboxed themselves. https://jasonelle.com/jasonette-old-docs/web/. https://jasonelle.com/jasonette-old-docs/agents/. Protocol Based Communication between Containers: All containers must communicate with each other through standard protocols instead of directly executing actions remotely. Otherwise we end up with too tightly coupled dependency, which makes the code complex, difficult to reuse unless you‚Äôre a programmer, and hard to understand. Let‚Äôs look into how the sandbox model works in Jasonette. 9.3.2 Agents and Web Container In communicating with agents and web containers, Jasonette puts top priority on security, which is why each container and agent is completely sandboxed from the outside world, and the only way to communicate is through a pre-defined JSON-RPC protocol. 9.3.3 Local Variables Same goes for communication between views. All views are completely sandboxed, you may be able to transition from one view to another, and you may be able to pass messages, but one view cannot directly execute actions in another view. Also, all local variables are sandboxed per view. There are two types of read/write local variables, ‚Äúlocal‚Äù meaning they are sandboxed to the parent view. Ephemeral Local Variable: Tied to a view through URL, only on memory, so it goes away when the user navigates away. You can write through $set action and read through $get Cache Local Variable: Similar to ephemeral local variable, but stays persisted instead of going away after the user navigates away. You can write through $cache.set and read through $cache.[variable name]. This means View A can‚Äôt access anything that belongs to View B and vice versa. This is the security model web browsers use, and is critical to building secure apps with loosely coupled views. Just to be clear, there does exist a way to implement a shared data layer using $global but that‚Äôs out of scope for this article. The point is, when you define a local variable from a view, there is no way other views can access them. OK it‚Äôs great to know it‚Äôs secure, but a question arises: ‚ÄúWhat if I want View A and View B to communicate?‚Äù. 9.3.4 Cross-View Communication Protocol We have a new addition to Jasonette that makes this possible while securing the sandboxed nature of views. Here‚Äôs a typical sequence of events: View A sends data to View B. View B uses the data to carry out tasks and return a response back to View A. View A can continue on with the return value it received from View B. Does this sound familiar? It‚Äôs like a function call!. Also, it is a similar security model to the request-and-response model employed by agents and web container. Below I‚Äôll explain each step of the communication process. 9.3.4.1 Step 1. Calling a View with Parameters First we pass some parameters to the next view through $href action. You define parameters under the options attribute. Here we pass two parameters firstName and lastName: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;https://jasonbase.com/things/3fj.json&quot;, &quot;options&quot;: { &quot;firstName&quot;: &quot;Bart&quot;, &quot;lastName&quot;: &quot;Simpson&quot; } } } The attributes will be accessible as $params.firstName and $params.lastName from the next view. This feature has been available from the beginning, so you may already know this. 9.3.4.2 Step 2. Go Back to Previous View with Return Values This feature is new. To return values back to the caller view, we use an action called $ok. Previously the only option we had of going back to the previous view was $back, which simply went back a level but didn‚Äôt have ability to pass a return value back. We can trigger $ok at any point in the view lifecycle. For example, we can immediately trigger it on $load to make it return immediately, like this: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;title&quot;: &quot;Return Immediately!&quot;, &quot;actions&quot;: { &quot;$load&quot;: { &quot;type&quot;: &quot;$ok&quot;, &quot;options&quot;: { &quot;fullName&quot;: &quot;{{$params.firstName}} {{$params.lastName}}&quot; } } } } } } Or we could let the user manually trigger $ok . This can be useful for accepting user input and returning the value to the previous view. For example: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;title&quot;: &quot;Form&quot; }, &quot;body&quot;: { &quot;sections&quot;: [{ &quot;items&quot;: [{ &quot;type&quot;: &quot;textfield&quot;, &quot;name&quot;: &quot;username&quot; }, { &quot;type&quot;: &quot;textfield&quot;, &quot;name&quot;: &quot;password&quot;, }, { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: &quot;Login&quot;, &quot;action&quot;: { &quot;type&quot;: &quot;$ok&quot;, &quot;options&quot;: { &quot;username&quot;: &quot;{{$get.username}}&quot;, &quot;password&quot;: &quot;{{$get.password}}&quot; } } }] }] } } } You can basically implement the $ok action anywhere to return to the previous view with return values. Here‚Äôs an example where a QR code scanner returns the scanned value back to the previous view: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;title&quot;: &quot;QR Scanner&quot;, &quot;actions&quot;: { &quot;$vision.ready&quot;: { &quot;type&quot;: &quot;$vision.scan&quot; }, &quot;$vision.onscan&quot;: { &quot;type&quot;: &quot;$ok&quot;, &quot;options&quot;: { &quot;response&quot;: &quot;{{$jason.content}}&quot; } }, // ... 9.3.4.3 Step 3. Process the Return Value with ‚Äúsuccess‚Äù callback In step 1 I only discussed a simple $href case where all it does is send some parameters to the next view. The $href action didn‚Äôt have a way to handle its return value. So even if we did everything correctly from the next view and returned via $ok action, there would not be a way to deal with them. Let‚Äôs make a small tweak to the JSON markup and add a success callback to handle the return value: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;https://jasonbase.com/things/3fj.json&quot;, &quot;options&quot;: { &quot;firstName&quot;: &quot;Bart&quot;, &quot;lastName&quot;: &quot;Simpson&quot; } }, &quot;success&quot;: { &quot;type&quot;: &quot;$util.alert&quot;, &quot;options&quot;: { &quot;title&quot;: &quot;Full Name&quot;, &quot;description&quot;: &quot;Full Name is: {{$jason.fullName}}&quot; } } } When you come back from the other view through the $ok action, its options object is returned as $jason, and you can continue on with the rest of the action call chain. So what actually happens when Jasonette runs the above $href markup is: It transitions to the next view with Bart and Simpson as parameters. Meanwhile, the caller view is waiting for the callee view to return with $ok. Rest of the action call chain is paused. The next view immediately comes back to the caller view and returns &quot;Bart Simpson&quot; stored under fullName attribute. Now that the caller view has access to the fullName attribute through $jason variable, it can continue on with rest of the action call chain. 9.3.5 Conclusion Building apps in a tightly coupled manner results in less transparency and consequently less security. This is why breaking an app down to multiple functional sandboxed views is a good idea and why that forms the basis of Jasonette‚Äôs core architecture. The two way communication protocol between Jasonette views ensure that views are loosely coupled. This architecture is similar to the secure sandbox model of web browsers, but it also adds one additional ability that web browsers don‚Äôt support. It lets views communicate with each other through the $href and $ok protocols, resembling a microservice architecture but implemented on the mobile frontend. You can learn more about $href action here: https://jasonelle.com/jasonette-old-docs/actions/#href. You can learn more about $ok action here: https://jasonelle.com/jasonette-old-docs/actions/#ok. You can learn more about all other ways of returning from a view here: https://jasonelle.com/jasonette-old-docs/actions/#view. 9.4 Apps for a Lifetime This article was written by CLSource Many of us create mobile apps for a living. Of all the software being made today, mobile apps have the saddest future. Little fragments composed by ones and zeroes working on a device that fits in your pocket. Some use smartphones for communication, others use them for entertainment, working, etc. Many users ignore the enormous effort and dedication that is required to give life an app. It‚Äôs a shame all those hours that developers, designers, managers and other people invested in the app‚Äôs creation process. Can be lost and forgotten forever. 9.4.1 A trip to the future Let‚Äôs go some years to the future. Year 2062. Maybe you formed a happy family. Your friends and relatives will have kids, nephews, grandchildren, and so on. One of them ask you how it was living in the 2010‚Äôs as a Software Developer. What was an iPhone?, How apps were made?, How they worked?, Can I still use them now?. As a software developer you could tell them by your memories and experiences. But people in the future will never experience apps the same way we do it now. 9.4.2 State of the Art If we want to experience software made 15, 20 or 30 years ago, we can use them without much trouble. Simply use a virtual machine, emulators or using the original hardware if you are lucky enough. We can learn from those software applications by using them. Software made 15 years ago required little or no internet access to function. They didn‚Äôt need ‚Äúcloud‚Äù servers or ‚Äúsocial media platforms‚Äù to deliver access to the features. Now you can easily play games, and use enterprise or offimatic software by using virtual machines or another techniques. Today such kind of software is made too (that could still be used in 15 years), but for mobile apps is a totally different scenario. Mobile apps are super difficult to be preserved for future generations and will fall in a digital black hole. 9.4.3 Space Jam Let‚Äôs look to this example. The Space Jam movie website (https://www.warnerbros.com/archive/spacejam/movie/jam.htm). More than 20 years have passed since it‚Äôs debut in 1996 and still we can enjoy it with a modern browser. Also it can be easily preserved using tools like the web archive (http://web.archive.org/web/20170102152426/https://www.warnerbros.com/archive/spacejam/movie/jam.htm) so if Warner Bros decides to shut it down we could still see the website. 9.4.4 The Mobile App Blackhole When iOS 11 arrived many 32 bit applications died for ever. But this was not the first time an operating system update causes troubles with mobile apps. Let‚Äôs see this page from 2015 https://www.polygon.com/2015/10/7/9470351/telltale-games-titles-removed-from-app-store-due-to-ios-9-issues. ‚ÄúBack to the Future, A Wolf Among Us, and other mobile ports of Telltale Games‚Äô adventure tiles have been removed from the App Store following problems with the new iOS9. ‚Äî Polygon.com‚Äù 9.4.5 Why this Mobile Blackhole Happens? Many motives could be behind an app‚Äôs shutdown. The following motives could affect most applications: An Operating system update deletes deprecated libraries and functions. Apps that use those libraries and functions will cease to work. A cloud service changes it‚Äôs api structure, policies or it‚Äôs deleted. Services like Facebook, Twitter, iCloud and many others. A clear example was the death of Parse (A Backend as A Service). http://blog.parse.com/announcements/moving-on/. Causing a lot of apps to be re-enginered or simply left for dead. Hardware device is obsolete and not supported by manufacturer any more. Some apps are highly coupled with the device‚Äôs hardware. If the hardware changes too much and the app is not updated, slowly the app will be forgotten. Google, Apple, Microsoft or ‚ÄúCompany X‚Äù will cease to exist. These big companies control the application stores. We can not guarantee that in 500 years these companies will still be alive and supporting the eco-systems made today. They have total control of the mobile app‚Äôs enviroment. We can not archive such enviroments or create emulators that can re create what we have today. Original creator of the application is dead. A bankrupcy or simply bought by a bigger company that is not interested in maintained older apps. App was removed due to other motives like legal rights problems. App does not make enough money to justify or pay maitainence efforts. Initiatives like The Internet Archive (https://archive.org/) try to solve this ‚Äúblackhole‚Äù problem of our digital age. Millions of documents, audios, videos, websites and older software are being preserved for future generations. But it‚Äôs virtually impossible to replicate and archive the same environment needed for an App that uses Facebook, Stripe.com and some other services to fully function. 9.4.6 Apps that can last 100 years Thanks to Jasonelle you can create apps that can last 100 years or more. Because they are made using JSON. Is natural to think that not all apps could be saved, specially those that require servers or use external dependencies. But if your apps consist mainly of static assets like json, javascript, images and videos you can be sure that as long as an interpreter exists you can replicate the behaviour of the app. This means the app is not coupled with Apple or Google systems. Is not a binary. Is a representation of data and logic that can be easily replicated with new technologies, vendor free. You could create a zip file with all the assets and then saved it in a public library. Then in 100 years anyone could open that file with an interpreter and your app will be alive. Make something useful, funny, weird or anything you could dream. And in 100 years people could still use that piece of software. That‚Äôs awesome. You can use other technologies for making apps. But they are coupled with the current mobile ecosystem. With Jasonelle you have the power to create a legacy and a make dent in the world. 9.4.7 Conclusion Mobile apps are different than a website or other software. Because mobile apps depends on ecosystems highly controled by companies like Apple or Google. They use cloud services that could die. This causes that mobile apps have a short life span of a couple of years, depending on the original creator to maintain them and if the conditions to work (servers, apis) don‚Äôt change or a kept up to date in the app. If any condition changes and the maintainer is gone. People will lost the oportunity to use the app and learn from it. The solution is using a technology that is vendor agnostic. A technology which can be interpreted the same way as HTML. We need a browser for apps. We need Jasonelle. "],
["external-resources.html", "10 External Resources 10.1 Instant Android Apps Article 10.2 Bubble Forums Posts 10.3 Old Jasonette Docs 10.4 Old Jasonette Blog", " 10 External Resources Resources that are external to this documentation. 10.1 Instant Android Apps Article An Article in Linux Magazine written by Dmitri Popov. Link: http://www.linux-magazine.com/Issues/2018/210/Jasonette. Code: https://github.com/jasonelle/jasonette-tokio-taxi. 10.2 Bubble Forums Posts Some forums posts written by John Mark about using https://bubble.is technology alonside Jasonelle. [Link]: https://forum.bubble.is/t/10-min-to-convert-your-site-into-an-iphone-ios-android-app/60923. 10.3 Old Jasonette Docs The old docs from Jasonette.com has been restored. Link: http://jasonelle.com/jasonette-old-docs/ 10.4 Old Jasonette Blog The old blog from Jasonette.com has been restored, and the links updated to the new locations. Link: http://jasonelle.com/jasonette-old-blog/ "],
["graveyard.html", "11 Graveyard 11.1 Cell.js", " 11 Graveyard The following section stands for shelved projects. 11.1 Cell.js Cell.js was a framework to simplify web development using JSON like structures. In the following blog post https://jasonelle.com/blog/cell-js-is-deprecated/, Jasonelle Team anounced that the Cell.js project was now deprecated and no longer maintained. However, you can access plenty of code examples here https://github.com/jasonelle/docs/tree/develop/examples/celljs. Jasonelle Team recommends the following frameworks as replacements: https://svelte.dev/ https://mithril.js.org/ "]
]
