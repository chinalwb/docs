[
["index.html", "Jasonelle Documentation 1 Welcome", " Jasonelle Documentation Jasonelle Team 2019-03-27 1 Welcome Jasonelle Family is made of several components that share JSON as the main language. "],
["history.html", "2 History", " 2 History Jasonette was created by ‚ÄúEthan Gliechtenstein‚Äù, a New York developer. Probably from Bushwick. Who‚Äôs real identity nobody knows. Jasonette core began in Late 2014 as an app named ‚ÄúEthan‚Äù (http://www.textethan.com/) It got quickly popular. Human Siri https://twitter.com/Kelvin_T_/status/557001903851065346 Tech Crunch https://techcrunch.com/2014/10/30/meet-samantha-ethan-apps-sister/ Ny Times https://www.nytimes.com/2014/12/18/style/ethan-siri-meets-dr-phil.html The Guardian https://www.theguardian.com/technology/2014/dec/04/-sp-ten-best-messaging-apps CNN http://www.cnn.com/2014/10/11/tech/askethan-app Spiegel http://www.spiegel.de/netzwelt/apps/ask-ethan-app-beantwortet-fragen-der-nutzer-a-997335.html NewsNet5 http://www.newsnet5.com/the-now/some-guy-named-ethan-created-a-smartphone-app-ask-him-anything-and-get-answers Dazed Digital http://www.dazeddigital.com/artsandculture/article/22152/1/this-irl-siri-app-wants-to-answer-all-your-burning-questions Business Insider http://www.businessinsider.com/ethan-is-the-top-app-on-product-hunt-2014-10 SFGate http://www.sfgate.com/business/article/Stupid-apps-but-not-always-a-stupid-idea-5843629.php Some time after that Ethan began extracting the core, refining the api and creating documentation. Finally releasing the first version of Jasonette on November 3th 2016. https://www.producthunt.com/posts/jasonette https://twitter.com/jasonclient/status/794175517763272708 Ethan worked on Jasonette, Cell and ST for nearly 2 years straight full-time. Until June 9 2018 were he misteriosly disappeared without a trace. Later on November 6th 2018. Jasonelle Team took the lead. The original repositories of Jasonette, Cell and ST are: https://github.com/jasonette https://github.com/intercellular https://github.com/selecttransform PD: If you want to know that character Ethan uses it‚Äôs Kon from Bleach üíØ (http://bleach.wikia.com/wiki/Kon) "],
["cell-js.html", "3 Cell.js 3.1 About", " 3 Cell.js 3.1 About "],
["jasonette.html", "4 Jasonette 4.1 Introduction", " 4 Jasonette Quite a different way to make an app. Make iOS and Android apps with just a single JSON, loaded over HTTP, local file, or anywhere. It has never been trivial to have an idea and turn it into an app quickly. Even for genius programmers. With Jasonette, you don‚Äôt even have to be a programmer. Anyone can make an app. And do it in minutes, not days or weeks. Make an app as fast as it takes to write a blog post. 4.1 Introduction Jasonette abstracts away all low level programming with a JSON based markup. All you need to write is a single JSON. 4.1.1 JSON to Native Components Just like how web browsers turn HTML into a web page, Jasonette turns JSON into iOS and Android native components. This lets you build native apps by writing a simple JSON. Native App over JSON 4.1.1.1 Structure Organize your code in nested JSON objects. Example: { &quot;$jason&quot;: { &quot;head&quot;: {...}, &quot;body&quot;: { &quot;sections&quot;: [{ &quot;items&quot;: [ { &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;...&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;...&quot; }, ... ] }] } } } 4.1.1.2 Layout Construct complex layouts with JSON. Example: Build a card UI with an image, labels, and nested layouts. { &quot;type&quot;: &quot;horizontal&quot;, &quot;components&quot;: [ { &quot;type&quot;: &quot;image&quot;, &quot;url&quot;: &quot;file://ethan.jpeg&quot; }, { &quot;type&quot;: &quot;vertical&quot;, &quot;components&quot;: [ { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Ethan&quot; }, { &quot;type&quot;: &quot;label&quot;, &quot;text&quot; &quot;www.textethan.com&quot; } ] } ] } 4.1.1.3 Actions Describe actions with JSON. Example: Make a network request and draw the result. { &quot;type&quot;: &quot;$network.request&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;http://api.giphy.com/v1/gifs/search&quot;, &quot;data&quot;: { &quot;q&quot;: &quot;kitten&quot;, &quot;api_key&quot;: &quot;dc6zaTOxFJmzC&quot; } }, &quot;success&quot;: { &quot;type&quot;: &quot;$render&quot; } } 4.1.1.4 Style Style components with JSON. Example: Style a label. { &quot;type&quot;: &quot;label&quot;, &quot;text&quot;: &quot;Hello World&quot;, &quot;style&quot;: { &quot;padding&quot;: &quot;10&quot;, &quot;corner_radius&quot;: &quot;5&quot;, &quot;background&quot;: &quot;rgba(0,0,0,0.4)&quot;, &quot;color&quot;: &quot;#ffffff&quot;, &quot;font&quot;: &quot;HelveticaNeue&quot; } } 4.1.1.5 Native App Over JSON Directly manipulate native APIs simply using JSON. For Android, this means direct access to LinearLayout, RecyclerView, etc. For iOS, this means direct access to UITableView, UIStackView, etc. Want to make changes to your LIVE app? Simply change your JSON content on the server, and watch the app change in front of your eyes, instantly!. 4.1.1.6 Native Components These are some Native Components you can access using just JSON. And much more! Including: Direct access to the device such as camera, audio, geolocation, video, network request, etc. Powerful layout engine that directly manipulates native components such as UITableView, UIStackView, UIView, etc. Describe styling and event handling all with JSON 4.1.1.7 Cross Platform 100% native binary for both Android and iOS. iOS Android 4.1.2 Free &amp; Battle Tested Jasonette was extracted from several production apps on the App Store, so you know it works. Below are some actual production apps built with Jasonette. Kitty Catch All 4.1.2.1 100% FREE Everything is free for you to use. There is no small print that says ‚Äúpay \\($\\) if you want to publish your app‚Äù. It‚Äôs all yours. 4.1.2.2 100% OPEN SOURCE Jasonette is licensed under MIT license. Take the code, build and publish your own apps, and do whatever you want with it! 4.1.2.3 100% PORTABLE There is no magical backend server you need to learn to use, pay for, or install to use Jasonette. ALL YOU NEED IS JSON. If you have a web server, you ALREADY have a Jasonette server. 4.1.2.4 100% EXTENSIBLE Jasonette is essentially just an engine that maps JSON expression to native components and actions. It doesn‚Äôt force you to drop everything and adopt the technology exclusively. You can extend it or even integrate it with your existing native code seamlessly. "],
["selector-transformer.html", "5 Selector Transformer", " 5 Selector Transformer "],
["tools.html", "6 Tools", " 6 Tools "],
["jasonette-tutorials.html", "7 Jasonette Tutorials 7.1 Build a QRCode/Barcode scanning app with 26 lines of JSON 7.2 Turn Your Website into a Mobile App with 7 Lines of JSON", " 7 Jasonette Tutorials The following tutorials are using Jasonette as the main technology. 7.1 Build a QRCode/Barcode scanning app with 26 lines of JSON This tutorial was posted by Ethan on Medium Nowadays we see QR code everywhere. We see it on a billboard, we see it embedded in product packaging, we use it to share Bitcoin public key. QR code is like a 2D version of barcode. As a publisher, you can pack all kinds of data in it as an image, and as a consumer you can simply scan the QR code to extract whatever is stored in the code. Both web.jasonette.com and jasonbase.com websites incorporate QR Code scanning, so you can just open your JASON app and scan the QR code to automatically open the app. Scan the QR code from JASON app to load the app But you can do much more than just storing a URL in a QR code. Let‚Äôs take a look at how you can implement the QR code feature for your app too. Like any other features on Jasonette, it‚Äôs all built into Jasonette, so you don‚Äôt need to do anything. You just need to load a JSON markup that instructs Jasonette to scan QR code. 7.1.1 How to implement You can implement barcode &amp; QR code scanning using a newly added API called $vision. Here‚Äôs how you implement them: 1 - Include back facing camera as background, as follows: { &quot;$jason&quot;: { &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 2 - Wait for $vision.ready event and call $vision.scan action You need to wait for the camera to be ready before calling the scan action. { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$vision.ready&quot;: { &quot;type&quot;: &quot;$vision.scan&quot; } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 3 - Now wait for $vision.onscan event This will be triggered once when the camera scans a new barcode. The event will return the data inside $jason, which you can parse to use it for your own purpose, like below: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$vision.ready&quot;: { &quot;type&quot;: &quot;$vision.scan&quot; }, &quot;$vision.onscan&quot;: { &quot;type&quot;: &quot;$util.alert&quot;, &quot;options&quot;: { &quot;title&quot;: &quot;Scanned&quot;, &quot;description&quot;: &quot;{{$jason.content}}&quot; } } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;camera&quot;, &quot;options&quot;: { &quot;device&quot;: &quot;back&quot; } } } } } 7.1.2 Simple and Flexible, works on both iOS and Android. Believe it or not, I have just introduced you to the entirety of the $vision API. No need to write native code or install additional features, it‚Äôs already all built into Jasonette-iOS and Jasonette-Android. Just load the JSON markup from Jasonette and it should just work. This works not just for the QR code, but also for regular ‚Äúone dimensional‚Äù barcode we‚Äôre all familiar with. Just like any other Jasonette actions, you can chain the scanned data with other Jasonette action to achieve whatever you need to build. For example you could: Automatically open a web page by scanning a QR code containing a URL Render any UI component using $render and passing the scanned data to a template. etc. Below you see another example which scans barcode and qrcode, and displays the content on the screen in realtime: Check out the code for above example in Jasonpedia. 7.1.3 Conclusion QR code is really cool, and Jasonette makes it super easy to implement it just by writing a few lines of JSON markup. Not only is it easy, but it‚Äôs also very flexible, since you can pass the return value to any other action to build whatever you want. Please play with it and share if you come up with any cool examples. Have fun! 7.2 Turn Your Website into a Mobile App with 7 Lines of JSON A New Approach for Blending Web Engine into Native Apps This tutorial was posted by Ethan on FreeCodeCamp. What if I told you the 7 lines of JSON above, colored in orange is all you need to turn a website into a mobile app? No need to rewrite your website using some framework API just to make it behave like a mobile app. Just bring your existing website as is, and blend it into a native app with a simple URL reference. And what if, just by tweaking the JSON markup a bit, you can access all the native APIs, native UI components, as well as native view transitions out of the box? Here‚Äôs what a minimal example looks like in action: Notice how I‚Äôve embedded a github.com web page but the rest of the layout is all native UI components, such as the navigation header and the bottom tab bar. And the transition is automatically native without you having to rewrite the website using any APIs. Before I explain how, you may ask: ‚ÄúThat‚Äôs cool, but can you do anything meaningful other than just displaying the web page in a native app frame?‚Äù Great question, because that‚Äôs the main topic of this post. All you need to do is create a seamless 2-way communication channel between the web view and the app, so the parent app can trigger any JavaScript functions inside the web view and the web view can reach outside to call native APIs. Here‚Äôs one such example: Note that this view contains: Native navigation header, complete with built-in transition functionality A Web view, which embeds a QR code generator web app A native chat input component at the bottom All this can be described by just tweaking some of the JSON markup attributes we saw above. Finally, note that the QR code changes as you enter something from the chat input. The chat input triggers a JavaScript function inside the QR code web app that re-generates the image. No app development framework has tried to fundamentally solve this problem of ‚Äúseamless integration of web view into native apps‚Äù because they‚Äôre all focused on picking either 100% native or 100% HTML5 side. Whenever you hear someone talk about the future of mobile apps, you would probably hear them talk about ‚ÄúWill it be the HTML5 approach that wins out? Or will it be native?‚Äù. None of them see native and html as something that could co-exist and furthermore, create synergy and achieve things that are not easily possible otherwise. In this article I‚Äôm going to explain: Why blending web engine and native components is often a good idea. Why a seamless integration of HTML and Native is not easy, and how I implemented one. Most importantly, how YOU can use it to build your own app instantly. 7.2.1 Why would you use HTML in a native app? Before we go further, let‚Äôs first discuss whether this is even a good idea, and when you may want to take this approach. Here are some potential use cases: Use Web Native Features Some parts of your app may be better implemented using the web engine. For example, Websocket is a web-native feature that‚Äôs designed for the web environment. In this case it makes sense to use the built-in web engine (WKWebView for iOS and WebView for Android) instead of installing a 3rd party library that essentially ‚Äúemulates‚Äù Websocket. No need to install additional code just to do something that you can do for free, which brings us to the next point. Avoid Large Binary Size You may want to quickly incorporate features that will otherwise require a huge 3rd party library. For example, to incorporate a QR code image generator natively, you will need to install some 3rd party library which will increase the binary size. But if you use the web view engine and a JavaScript library through a simple &lt;script src&gt;, you get all that for free, and you don‚Äôt need to install any 3rd party native libraries. No Reliable Mobile Library Exists For some cutting edge technologies, there is no reliable and stable mobile implementation yet. Fortunately most of these technologies have web implementations, so the most efficient way to integrate them is to use their JavaScript library. Build part-native, part-web-based apps Many new developers looking to port their website into a mobile app get discouraged or overwhelmed when they find out some of their existing website features are too complex to quickly rewrite from scratch for each mobile platform. For example, you may have a single web page that‚Äôs too complex to immediately convert to a mobile app, but the rest of your website may be easily converted. In this case, it would be nice if there was a way to build most of the app natively, but for that particular complex web page, somehow seamlessly integrate it into the app as HTML. 7.2.2 How does it work? Jasonette Jasonette is an open source, markup-based approach to building cross-platform native apps. It‚Äôs like a web browser, but instead of interpreting HTML markup into web pages, it interprets JSON markup into native apps on iOS and Android. Just like how all web browsers have exactly the same code but can deliver you all kinds of different web apps by interpreting various HTML markup on demand, all Jasonette apps have exactly the same binary, and it interprets various JSON markup on demand to create your app. The developers never need to touch the code. Instead, you build apps by writing a markup that translates to native app in real-time. You can learn more about Jasonette here. While Jasonette at its core is all about building native apps, this particular article is about integrating HTML into the core native engine, so let‚Äôs talk about that. Jasonette Web Container Native apps are great but sometimes we need to make use of web features. But integrating web views into a native app is a tricky business. A seamless integration requires: Web view should be integrated as a part of native layout: The web view should blend into the app as a part of the native layout and is treated just like any other native UI components. Otherwise it will feel clunky, and it will feel exactly like what it is a website. Parent app can control child web container: The parent app should be able to freely control the child web view. Child web container can trigger native events on the parent app: The child app should be able to trigger the parent app‚Äôs events to run native APIs. These are a lot of work, so I first worked on only the first piece of the puzzle simply embedding a web container into native layout and released it as version 1. This was already pretty useful, but it still had the limitation of being non-interactive. The parent app couldn‚Äôt control the child web container, and the child couldn‚Äôt notify the parent of any event, keeping the web container completely isolated from the outside world. Jasonette Web Container 2.0: Make it Interactive After releasing version 1, I experimented with the second piece of the puzzle adding interactivity to the web container. The next section explains the solutions that were added to make the previously-static web containers interactive, making them significantly more powerful. 7.2.3 Implementation: Interactive Web Container 1 - Load by URL Problem Previously in version 1, to use web container as a background view component, you had to first set the $jason.body.background.type to &quot;html&quot; and then hard-code the HTML text under $jason.body.background.text attribute like this: { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;text&quot;: &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; } } } } Naturally people wanted to be able to instantiate the container using simply a web URL instead of having to hardcode the entire HTML text in a single line. Solution Web container 2.0 has added the url attribute. You can embed a local file:// HTML like this (it loads from the local HTML file you ship with the app): { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot; } } } } Or embed a remote http[s]:// URL like this (it loads from a remote HTML): { &quot;$jason&quot;: { &quot;head&quot;: { ... }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;https://news.ycombinator.com&quot; } } } } 2 - Parent App &lt;=&gt; Web Container Communication Problem Previously, web containers were only for displaying content, and not interactive. This meant NONE of the following was possible: Jasonette =&gt; Web Container: Call JavaScript functions inside the web container from Jasonette. Web Container =&gt; Jasonette: Call native API from web container code. All you could do was display the web container. This was similar to how you would embed an iframe in a web page, but the main web page had no access to what was inside the iframe. Solution The whole point of Jasonette is to design a standard markup language to describe cross platform mobile apps. In this case, we needed a markup language that could comprehensively describe communications between the parent app and the child web container. To achieve this, I came up with a JSON-RPC based communication channel between the parent app and the child web container. Since everything on Jasonette is expressed in JSON objects, it made perfect sense to use the JSON-RPCstandard format as the communication protocol. To make a JavaScript function call into the web container, we declare an action called $agent.request: { &quot;type&quot;: &quot;$agent.request&quot;, &quot;options&quot;: { &quot;id&quot;: &quot;$webcontainer&quot;, &quot;method&quot;: &quot;login&quot;, &quot;params&quot;: [&quot;username&quot;, &quot;password&quot;] } } $agent.request is the native API that triggers a JSON-RPC request into the web container. To use it, we must pass an options object as its parameter. The options object is the actual JSON-RPC request that will be sent to the web container. Let‚Äôs look at what each attribute means: id: Web container is built on top of a lower level architecture called agent. Normally you can have multiple agents for a single view, and each agent can have its unique ID. But Web container is a special type of agent which can only have the id of $webcontainer, which is why we use that ID here. method: The JavaScript function name to call. params: The array of parameters to pass to the JavaScript function. The full markup would look something like this: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;$load&quot;: { &quot;type&quot;: &quot;$agent.request&quot;, &quot;options&quot;: { &quot;id&quot;: &quot;$webcontainer&quot;, &quot;method&quot;: &quot;login&quot;, &quot;params&quot;: [&quot;alice&quot;, &quot;1234&quot;] } } } }, &quot;body&quot;: { &quot;header&quot;: { &quot;title&quot;: &quot;Web Container 2.0&quot; }, &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot; } } } } This markup is saying: When the view loads ($jason.head.actions.$load), make a JSON-RPC request into the web container agent ($agent.request) where the request is specified under options. The web container is defined under $jason.body.background, which in this case loads a local file called file://index.html. It will look for a JavaScript function called login and pass the two arguments under params ( &quot;alice&quot; and &quot;1234&quot;). login(&quot;alice&quot;, &quot;1234&quot;) I‚Äôve only explained how the parent app can trigger the child web container‚Äôs JavaScript function calls, but you can also do the opposite and let the web container trigger the parent app‚Äôs native API. To learn more, check out the agent documentation. Example Let‚Äôs come back to the QR code example I briefly shared above: The footer input component is 100% native. The QR code is generated by the web container as a web app. When a user enters something and presses ‚ÄúGenerate,‚Äù it calls $agent.request action into the web container agent, calling the JavaScript function ‚Äúqr‚Äù. You can check out the example here. 3 - Script Injection Problem Sometimes you may want to dynamically inject JavaScript code into the web container AFTER it‚Äôs finished loading the initial HTML. Imagine you want to build a custom web browser app. You may want to inject your own custom JavaScript into every web view to customize the web view‚Äôs behavior, kind of like how web browser extensions work. Even if you‚Äôre not building a web browser, you may want to use the script injection method whenever you want a custom behavior for a URL whose content you have no control over. The only way to communicate between the native app and the web container is through the $agent API. But if you can‚Äôt change the HTML content, the only way to add the $agent interface into the web container is through dynamic injection. Solution As mentioned in the previous section, the $jason.body.background web container is just another agent. This means you can use the same $agent.inject method available to regular agents. 4 - URL Click Handling In the past, there were only two ways a web container could handle link clicks: Readonly: Treat the web container as readonly and ignore all events such as touch or scroll. All web containers are readonly unless you tell them to behave like a regular browser, as described below. Regular Browser Behavior: Let users interact with the page by behaving like a normal browser. You declare it by setting &quot;type&quot;: &quot;$default&quot; as its action attribute. Problem Both are ‚Äúall or nothing‚Äù solutions. In the ‚ÄúReadonly‚Äù case, all your interactions are completely ignored by the web container. In the ‚ÄúRegular Browser Behavior‚Äù case, the web container functions literally as a browser. When you click a link, it would just send you to that link by refreshing the page just like a web page. There was no way to hijack the click and call some native API. Solution With the new web container, you can now attach any action on the $jason.body.background web container to handle link click events. Let‚Äôs look at an example: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;displayBanner&quot;: { &quot;type&quot;: &quot;$util.banner&quot;, &quot;options&quot;: { &quot;title&quot;: &quot;Clicked&quot;, &quot;description&quot;: &quot;Link {{$jason.url}} clicked!&quot; } } } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;displayBanner&quot; } } } } } Here we have attached &quot;trigger&quot;: &quot;displayBanner&quot; to the web container. This means that when a user clicks any link in the web container, it will trigger displayBanner action instead of letting the web view handle it. Also, if you look at the displayBanner action, you‚Äôll notice the $jason variable. In this case, the clicked link will be passed through the $jason variable. For example, if you clicked a URL named &quot;https://google.com&quot;, the $jason will have the following value: { &quot;url&quot;: &quot;https://google.com&quot; } This means you can selectively trigger different actions by checking the $jason.url value. Let‚Äôs take another example where we implement a custom web browser: { &quot;$jason&quot;: { &quot;head&quot;: { &quot;actions&quot;: { &quot;handleLink&quot;: [{ &quot;{{#if $jason.url.indexOf(&#39;signin&#39;) !== -1 }}&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;file://key.html&quot; } } }, { &quot;{{#else}}&quot;: { &quot;type&quot;: &quot;$default&quot; } }] } }, &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;file://index.html&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;handleLink&quot; } } } } } We test if the URL contains the string signin and then run two different actions depending on the result. If it contains signin, it opens a new view to take care of signing in natively. If it doesn‚Äôt contain signin, just run the &quot;type&quot;: &quot;$default&quot; action so that it behaves like a regular browser. 7.2.4 Example Usage Building a custom web browser We can now take advantage of the fact that the new web container can: Take a url attribute to load itself, functioning as a full-fledged browser Selectively handle link clicks depending on the URL We can even build a custom web browser app with just a dozen lines of JSON. Since we can now hijack every link click, we can take a look at $jason.url and run whatever actions we want depending on the URL. For example, take a look at the example below: On the left side we see that clicking a link behaves like a regular browser (&quot;type&quot;: &quot;$default&quot;) On the right side we see that clicking a link does a native transition to another JASON view. All this can be achieved by selectively triggering different actions based on $jason.url. Step 1. Attach an action named visit to the web container like this: { ... &quot;body&quot;: { &quot;background&quot;: { &quot;type&quot;: &quot;html&quot;, &quot;url&quot;: &quot;https://news.ycombinator.com&quot;, &quot;action&quot;: { &quot;trigger&quot;: &quot;visit&quot; } } } } Step 2. Run relevant actions inside visit, based on $jason.url In the following code, we‚Äôre checking if $jason.url matches newest, show, ask, and so on (they‚Äôre the top menu item links). If they do, we let the web container behave like a regular browser by setting &quot;type&quot;: &quot;$default&quot;. If they don‚Äôt match the pattern, we make a native $href transition to a new view and pass the clicked link as a parameter. ... &quot;actions&quot;: { &quot;visit&quot;: [ { &quot;{{#if /\\\\/(newest|show|ask)$/.test($jason.url) }}&quot;: { &quot;type&quot;: &quot;$default&quot; } }, { &quot;{{#else}}&quot;: { &quot;type&quot;: &quot;$href&quot;, &quot;options&quot;: { &quot;url&quot;: &quot;https://jasonette.github.io/Jasonpedia/webcontainer/agent/hijack.json&quot;, &quot;preload&quot;: { &quot;background&quot;: &quot;#ffffff&quot; }, &quot;options&quot;: { &quot;url&quot;: &quot;{{$jason.url}}&quot; } } } } ] }, Check out the full JSON markup for the web browser here (it‚Äôs only 48 lines!). Instant ‚ÄúHybrid‚Äù App When people normally talk about ‚Äúhybrid‚Äù apps, they mostly mean HTML web apps wrapped inside a native app frame. But that‚Äôs not what I mean here. When I say ‚ÄúHybrid,‚Äù I mean a truly hybrid app, where one app can have multiple native views and multiple web-based views simultaneously. Also where one view can have multiple native UI components and a web container rendered in the same native layout. The cross-over between web-based view and native view should be so seamless that it‚Äôs hard to tell where one starts and ends. In this example, I‚Äôve created an app that displays jasonbase.com in a web container as the home view. Jasonbase is a free JSON hosting service I built to easily host JSON markup for Jasonette apps. Naturally, it‚Äôs just a website, but I have embedded it in Jasonette so that when you click the link, instead of opening a web page, it makes a native $href transition to a native JASON view. I didn‚Äôt have to touch any of Jasonbase.com‚Äôs code to build this app. I simply embedded the website into Jasonette as a web container, and hijacked the link clicks to handle them natively, so it can do all the native stuff like triggering native APIs and making native transitions. You can check out the code here. 7.2.5 Conclusion In my opinion, what makes all this work fabulously is that everything is taken care of on the framework level. All the hard work is taken care of behind the scenes. Instead of putting the burden on the app developers to implement all of the following from scratch: Embed a webview into native layout. Create a JavaScript bridge so the app can make function calls into the web view. Creating a native event handling architecture so the web view can trigger native events on the parent app. The solution was to create an abstraction made up of: Declarative Markup Language: for describing how to embed a web view into a native app. Communication Protocol (JSON-RPC): to allow dead-simple interactions between the app and its child web views. I don‚Äôt claim this approach to be the ultimate solution to solve everything, but I‚Äôm happy to say that this has been a great solution for my own use case. I was trying to build an app that builds on a super edge technology which has no stable and reliable mobile implementations (and it‚Äôs not clear if there ever will be a mobile implementation due to the protocol‚Äôs nature). Thankfully it had JavaScript implementations so I could easily integrate it into the app without hassle. Overall, it‚Äôs been great and I‚Äôm satisfied with how it turned out. The documentation is up to date to reflect all the new features, so feel free to dig in and play around. Disclaimer: With great power comes great responsibility I would like to end with a disclaimer: as great as this newly found power is, I think you need to keep a balance to build an app with a great user experience. Some may take this and build an entire app using web views only, but then you will end up with an app that‚Äôs basically just a website, which defeats the purpose of building a dedicated app. I emphasize that I‚Äôm not saying you should always build apps with both HTML and native. I am saying this can be very useful for many people in different situations. Just don‚Äôt go overboard with it. Follow Along to Learn More There are many different configurations in which the Jasonette native core and its child web container can communicate to get things done in creative and powerful ways, and this post is just scratching the surface. "],
["how-to-guides.html", "8 How To Guides", " 8 How To Guides "],
["discussions.html", "9 Discussions", " 9 Discussions "]
]
